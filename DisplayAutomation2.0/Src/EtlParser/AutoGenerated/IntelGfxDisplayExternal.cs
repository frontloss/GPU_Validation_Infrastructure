using System;
using System.Diagnostics;
using System.Diagnostics.Tracing;
using System.Text;
using Microsoft.Diagnostics.Tracing;
using Address = System.UInt64;

#pragma warning disable 1591        // disable warnings on XML comments not being present
#pragma warning disable 114, 108    // disable warnings on hiding inhertiting variable names

// This code was automatically generated by the TraceParserGen tool, which converts
// an ETW event manifest into strongly typed C# classes.
namespace Microsoft.Diagnostics.Tracing.Parsers
{
    using Microsoft.Diagnostics.Tracing.Parsers.IntelGfxDisplayExternal;

    [System.CodeDom.Compiler.GeneratedCode("traceparsergen", "2.0")]
    public sealed class IntelGfxDisplayExternalTraceEventParser : TraceEventParser 
    {
        public static string ProviderName = "Intel-Gfx-Display-External";
        public static Guid ProviderGuid = new Guid(unchecked((int) 0x31ab337f), unchecked((short) 0x8ba3), unchecked((short) 0x4145), 0x88, 0xf3, 0xce, 0xa5, 0x37, 0xbf, 0xe8, 0x61);
        public enum Keywords : long
        {
            Hdmi = 0x2,
            Dp = 0x4,
            Modeset = 0x8,
            Audio = 0x10,
            Flip = 0x20,
            Interrupt = 0x40,
        };

        public IntelGfxDisplayExternalTraceEventParser(TraceEventSource source) : base(source) {}

        public event Action<Aux_t> AuxRead
        {
            add
            {
                source.RegisterEventTemplate(AuxReadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 1, ProviderGuid);
            }
        }
        public event Action<AuxChannelToPortMap_t> AuxTransaction
        {
            add
            {
                source.RegisterEventTemplate(AuxTransactionTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 9, ProviderGuid);
            }
        }
        public event Action<AuxInfo_t> AuxTransactionReceive
        {
            add
            {
                source.RegisterEventTemplate(AuxTransactionReceiveTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 8, ProviderGuid);
            }
        }
        public event Action<AuxInfo_t> AuxTransactionSend
        {
            add
            {
                source.RegisterEventTemplate(AuxTransactionSendTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 7, ProviderGuid);
            }
        }
        public event Action<Aux_t> AuxWrite
        {
            add
            {
                source.RegisterEventTemplate(AuxWriteTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 2, ProviderGuid);
            }
        }
        public event Action<Aux_t> I2CAuxRead
        {
            add
            {
                source.RegisterEventTemplate(I2CAuxReadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 5, ProviderGuid);
            }
        }
        public event Action<Aux_t> I2CAuxWrite
        {
            add
            {
                source.RegisterEventTemplate(I2CAuxWriteTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 6, ProviderGuid);
            }
        }
        public event Action<I2C_t> I2CRead
        {
            add
            {
                source.RegisterEventTemplate(I2CReadTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 3, ProviderGuid);
            }
        }
        public event Action<I2C_t> I2CWrite
        {
            add
            {
                source.RegisterEventTemplate(I2CWriteTemplate(value));
            }
            remove
            {
                source.UnregisterEventTemplate(value, 4, ProviderGuid);
            }
        }

        #region private
        protected override string GetProviderName() { return ProviderName; }

        static private Aux_t AuxReadTemplate(Action<Aux_t> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new Aux_t(action, 1, 1, "Aux", Guid.Empty, 10, "Read", ProviderGuid, ProviderName );
        }
        static private AuxChannelToPortMap_t AuxTransactionTemplate(Action<AuxChannelToPortMap_t> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new AuxChannelToPortMap_t(action, 9, 4, "AuxTransaction", Guid.Empty, 0, "", ProviderGuid, ProviderName );
        }
        static private AuxInfo_t AuxTransactionReceiveTemplate(Action<AuxInfo_t> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new AuxInfo_t(action, 8, 4, "AuxTransaction", Guid.Empty, 240, "Receive", ProviderGuid, ProviderName );
        }
        static private AuxInfo_t AuxTransactionSendTemplate(Action<AuxInfo_t> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new AuxInfo_t(action, 7, 4, "AuxTransaction", Guid.Empty, 9, "Send", ProviderGuid, ProviderName );
        }
        static private Aux_t AuxWriteTemplate(Action<Aux_t> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new Aux_t(action, 2, 1, "Aux", Guid.Empty, 11, "Write", ProviderGuid, ProviderName );
        }
        static private Aux_t I2CAuxReadTemplate(Action<Aux_t> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new Aux_t(action, 5, 3, "I2CAux", Guid.Empty, 10, "Read", ProviderGuid, ProviderName );
        }
        static private Aux_t I2CAuxWriteTemplate(Action<Aux_t> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new Aux_t(action, 6, 3, "I2CAux", Guid.Empty, 11, "Write", ProviderGuid, ProviderName );
        }
        static private I2C_t I2CReadTemplate(Action<I2C_t> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new I2C_t(action, 3, 2, "I2C", Guid.Empty, 10, "Read", ProviderGuid, ProviderName );
        }
        static private I2C_t I2CWriteTemplate(Action<I2C_t> action)
        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
            return new I2C_t(action, 4, 2, "I2C", Guid.Empty, 11, "Write", ProviderGuid, ProviderName );
        }

        static private volatile TraceEvent[] s_templates;
        protected override void EnumerateTemplates(Func<string, string, EventFilterResponse> eventsToObserve, Action<TraceEvent> callback)
        {
            if (s_templates == null)
            {
                var templates = new TraceEvent[9];
                templates[0] = AuxReadTemplate(null);
                templates[1] = AuxWriteTemplate(null);
                templates[2] = I2CReadTemplate(null);
                templates[3] = I2CWriteTemplate(null);
                templates[4] = I2CAuxReadTemplate(null);
                templates[5] = I2CAuxWriteTemplate(null);
                templates[6] = AuxTransactionSendTemplate(null);
                templates[7] = AuxTransactionReceiveTemplate(null);
                templates[8] = AuxTransactionTemplate(null);
                s_templates = templates;
            }
            foreach (var template in s_templates)
                if (eventsToObserve == null || eventsToObserve(template.ProviderName, template.EventName) == EventFilterResponse.AcceptEvent)
                    callback(template);
        }

        #endregion
    }
}

namespace Microsoft.Diagnostics.Tracing.Parsers.IntelGfxDisplayExternal
{
    public sealed class Aux_t : TraceEvent
    {
        public int BDF(int arrayIndex) { return GetByteAt(0 + (arrayIndex * HostOffset(1, 0))); }
        public DP_AUX_CHANNEL_TYPE Channel { get { return (DP_AUX_CHANNEL_TYPE)GetInt32At(4); } }
        public uint Status { get { return (uint)GetInt32At(8); } }
        public uint Address { get { return (uint)GetInt32At(12); } }
        public int Size { get { return GetInt16At(16); } }
        public byte[] Data { get { return GetByteArrayAt(18, (int)Size); } }
        public uint ActualTxnSize { get { return (uint)GetInt32At(0+ ((int)Size*1)+18); } }

        #region Private
        internal Aux_t(Action<Aux_t> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected override void Dispatch()
        {
            m_target(this);
        }
        protected override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 0+ ((int)Size*1)+22));
            Debug.Assert(!(Version > 0 && EventDataLength < 0+ ((int)Size*1)+22));
        }
        protected override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<Aux_t>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Channel", Channel);
             XmlAttrib(sb, "Status", Status);
             XmlAttrib(sb, "Address", Address);
             XmlAttrib(sb, "Size", Size);
             XmlAttrib(sb, "Data", Data);
             XmlAttrib(sb, "ActualTxnSize", ActualTxnSize);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "BDF", "Channel", "Status", "Address", "Size", "Data", "ActualTxnSize"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 1:
                    return Channel;
                case 2:
                    return Status;
                case 3:
                    return Address;
                case 4:
                    return Size;
                case 5:
                    return Data;
                case 6:
                    return ActualTxnSize;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<Aux_t> m_target;
        #endregion
    }
    public sealed class AuxChannelToPortMap_t : TraceEvent
    {
        public int BDF(int arrayIndex) { return GetByteAt(0 + (arrayIndex * HostOffset(1, 0))); }
        public int ArraySize { get { return GetInt16At(4); } }
        public PORT_TYPES Map_AuxChannelToPort(int arrayIndex) { return (PORT_TYPES)GetInt32At(6 + (arrayIndex * HostOffset(4, 0))); }

        #region Private
        internal AuxChannelToPortMap_t(Action<AuxChannelToPortMap_t> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected override void Dispatch()
        {
            m_target(this);
        }
        protected override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 0+ ((int)ArraySize*4)+6));
            Debug.Assert(!(Version > 0 && EventDataLength < 0+ ((int)ArraySize*4)+6));
        }
        protected override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<AuxChannelToPortMap_t>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "ArraySize", ArraySize);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "BDF", "ArraySize", "Map_AuxChannelToPort"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 1:
                    return ArraySize;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<AuxChannelToPortMap_t> m_target;
        #endregion
    }
    public sealed class AuxInfo_t : TraceEvent
    {
        public int BDF(int arrayIndex) { return GetByteAt(0 + (arrayIndex * HostOffset(1, 0))); }
        public DP_AUX_CHANNEL_TYPE Channel { get { return (DP_AUX_CHANNEL_TYPE)GetInt32At(4); } }
        public int Size { get { return GetInt16At(8); } }
        public byte[] Data { get { return GetByteArrayAt(10, (int)Size); } }
        public uint Status { get { return (uint)GetInt32At(0+ ((int)Size*1)+10); } }

        #region Private
        internal AuxInfo_t(Action<AuxInfo_t> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected override void Dispatch()
        {
            m_target(this);
        }
        protected override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 0+ ((int)Size*1)+14));
            Debug.Assert(!(Version > 0 && EventDataLength < 0+ ((int)Size*1)+14));
        }
        protected override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<AuxInfo_t>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Channel", Channel);
             XmlAttrib(sb, "Size", Size);
             XmlAttrib(sb, "Data", Data);
             XmlAttrib(sb, "Status", Status);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "BDF", "Channel", "Size", "Data", "Status"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 1:
                    return Channel;
                case 2:
                    return Size;
                case 3:
                    return Data;
                case 4:
                    return Status;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<AuxInfo_t> m_target;
        #endregion
    }
    public sealed class I2C_t : TraceEvent
    {
        public int BDF(int arrayIndex) { return GetByteAt(0 + (arrayIndex * HostOffset(1, 0))); }
        public PORT_TYPES Port { get { return (PORT_TYPES)GetInt32At(4); } }
        public uint Slave { get { return (uint)GetInt32At(8); } }
        public uint Index { get { return (uint)GetInt32At(12); } }
        public uint Flags { get { return (uint)GetInt32At(16); } }
        public uint DataSize { get { return (uint)GetInt32At(20); } }
        public byte[] Data { get { return GetByteArrayAt(24, (int)DataSize); } }
        public uint Status { get { return (uint)GetInt32At(0+ ((int)DataSize*1)+24); } }
        public uint ActualTxnSize { get { return (uint)GetInt32At(0+ ((int)DataSize*1)+28); } }

        #region Private
        internal I2C_t(Action<I2C_t> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.m_target = target;
        }
        protected override void Dispatch()
        {
            m_target(this);
        }
        protected override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != 0+ ((int)DataSize*1)+32));
            Debug.Assert(!(Version > 0 && EventDataLength < 0+ ((int)DataSize*1)+32));
        }
        protected override Delegate Target
        {
            get { return m_target; }
            set { m_target = (Action<I2C_t>) value; }
        }
        public override StringBuilder ToXml(StringBuilder sb)
        {
             Prefix(sb);
             XmlAttrib(sb, "Port", Port);
             XmlAttrib(sb, "Slave", Slave);
             XmlAttrib(sb, "Index", Index);
             XmlAttrib(sb, "Flags", Flags);
             XmlAttrib(sb, "DataSize", DataSize);
             XmlAttrib(sb, "Data", Data);
             XmlAttrib(sb, "Status", Status);
             XmlAttrib(sb, "ActualTxnSize", ActualTxnSize);
             sb.Append("/>");
             return sb;
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "BDF", "Port", "Slave", "Index", "Flags", "DataSize", "Data", "Status", "ActualTxnSize"};
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 1:
                    return Port;
                case 2:
                    return Slave;
                case 3:
                    return Index;
                case 4:
                    return Flags;
                case 5:
                    return DataSize;
                case 6:
                    return Data;
                case 7:
                    return Status;
                case 8:
                    return ActualTxnSize;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<I2C_t> m_target;
        #endregion
    }
    public enum DP_AUX_CHANNEL_TYPE
    {
        AUX_CHANNEL_A = 0x0,
        AUX_CHANNEL_B = 0x1,
        AUX_CHANNEL_C = 0x2,
        AUX_CHANNEL_D = 0x3,
        AUX_CHANNEL_E = 0x4,
        AUX_CHANNEL_F = 0x5,
        AUX_CHANNEL_G = 0x6,
        AUX_CHANNEL_H = 0x7,
        AUX_CHANNEL_I = 0x8,
    }
    public enum PORT_TYPES
    {
        PORT_A = 0x0,
        PORT_B = 0x1,
        PORT_C = 0x2,
        PORT_D = 0x3,
        PORT_E = 0x4,
        PORT_F = 0x5,
        PORT_G = 0x6,
        PORT_H = 0x7,
        PORT_I = 0x8,
        NULL_PORT = 0xff,
    }
}
