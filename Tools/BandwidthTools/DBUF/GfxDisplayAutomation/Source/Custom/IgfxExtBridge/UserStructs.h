/*
 *  Copyright© 1999-2007, Intel Corporation
 *
 *  $Workfile: UserStructs.h $
 *  $Revision: 92 $
 *  $Modtime: 5/23/02 3:38a $
 *
 *  Purpose:   Defines Structures used as communications vehicle
 *             between the CUIDriver layer and the Upper layer CUI software
 *             respectively.  Does NOT define any structure information
 *             for data get/set from/to the Driver itself (unless by chance
 *             the structure happens to be the same).
 *
 *             Each GUID is associated with a structure, and is grouped
 *             accordingly by position within this file.
 *             Ie. All GUIDs that require a DWORD to be passed between
 *                 the layers are located immediately above the CUIDWORD struct.
 *
 *             Some other miscelaneous guids are also defined here, such as
 *             the DeviceChanged Guid, which is used when a call-back to CUI services
 *             is made in Asynch mode.
 *
 *
 *  Compiler:       Visual C++ 5.0  SP3
 *
 *  Ext Packages:   None
 *
 *  $Author: Skp $
 *
 *  Revisions:
 *  $Log: /Projects/PDD CommonUI/igfx/igfxdev/UserStructs.h $
 * 
 * 2     4/02/99 11:48a Bcbenham
 * Init rev.
 *
 *
 */


#ifndef __CUI_USERSTRUCTURES_H_
#define __CUI_USERSTRUCTURES_H_
//
//
//    RULE #1
//
//    ALL TOP-LEVEL STRUCTURES PASSED TO CUIDRIVER
//    MUST MUST MUST HAVE THE FIRST ELEMENT OF TYPE STRUCT CUIDriver_ERROR.
//    THIS GREATLY SIMPLIFIES CODING OF THIS LAYER, AND PROVIDES A
//    VERY CONSISTENT METHOD FOR EXTENDED ERROR HANDLING ON "UNDERSTOOD",
//    BUT FAILED REQUESTS.  SEE CUIDRIVER INTERFACE DOCUMENT.
//    (YES, EVEN SIMPLE DATA TYPES MUST BE EMBEDDED IN A STRUCTURE THAT
//    CONTAINS THE CUIDriver_ERROR structure as the first element.).
//

//      An element of this structure type must be included as the
//      FIRST member of every structure that is passed to/from the
//      CUIDriver layer. 
typedef struct
{
   BOOLEAN ErrorOccured;         // TRUE or FALSE
   DWORD LastSystemErrorVal;     // return from GetLastError() api call.
   enum CUIErrorCode ExtendedError;   //
   BSTR  ExtendedErrorBstr;      // Optional Use, use for Test purposes only!
}CUIDriver_ERROR;

// Used in CUIDriver_ERROR structure.  These represent errors generated by
// the CUI Driver that were NOT obtainable by a system call to the API GetLastError();
// Callers into CUIDriver should first check the LastSystemErrorVal member, and
// if zero, they should then look at the ExtendedError value to determine
// the error.  CUIDriver is not localized, so returning error information in this
// manner allows the caller to localize and customize their own error strings.
/*enum CUIErrorCode
{
   CUIERROR_NO_ERROR = 0,       //This is must because caller's buffer is already 0-ed
   CUIERROR_INVALID_DRIVERNAME,  // Caller never set the Vdd name, so DeviceIOControl
                                     // calls can never be made.
   CUIERROR_INVALID_EDID,            // Invalid EDID version retrieved from driver.
   CUIERROR_UNKNOWN_OPERATING_SYSTEM,   // Can't determine OS running on.
   CUIERROR_INVALID_DDC,         // Unknown DDC Value obtained from the Driver, or DDC not supported.
   CUIERROR_DRIVER_FAIL,         // Actual Call into Driver Failed.
   CUIERROR_INCORRECT_DEVICE,    // Call made to guid that supports different type of device only.
   CUIERROR_DRIVER_NOTSUPPORTED, // Actual Call into Driver returned not supported code.
   CUIERROR_INVALID_STATE,       // Something needed to be set ahead of the current call, and was not.
                                 // Also applies to when you forget to set the Device Context.
   CUIERROR_REGISTRY,            // Error reading or writing to registry.
   CUIERROR_UNKNOWN_GENERIC,     // General Error code that covers anything not covered by the other codes.
   CUIERROR_INVALID_PARAMETER,   // Input Parameter is wrong...
                                 // CheckMode2 Related Error Code 
   CUIERROR_CFG_DRV_NOT_SUPPORT, // The resolution is not supportable from display Driver 
   CUIERROR_CFG_DRV_NOT_SUPPORT_PRIMARY,   //Primary display mode is not supportable 
   CUIERROR_CFG_DRV_NOT_SUPPORT_SECONDARY,  //Secondary Mode is not supportable 
   CUIERROR_CFG_DEV_NOT_SUPPORT,           //Display Device does not support this configuration 
   CUIERROR_CFG_DEV_NOT_SUPPORT_PRIMARY,   //Display Device does not support for requested primary mode 
   CUIERROR_CFG_DEV_NOT_SUPPORT_SECONDARY, //Display Device does not Support for requested secondary mode

   CUIERROR_OUT_OF_MEMORY,

   CUIERROR_CUSTOMMODE_INVALID_PARAMETER,		//Invalid mode detail
   CUIERROR_EXISTING_MODE,						//Custom mode already exists
   CUIERROR_CUSTOMMODE_EXISTING_BASIC_MODE,		//Basic Custom mode already exists
   CUIERROR_CUSTOMMODE_EXISTING_DETAIL_MODE,	//Detail Custom mode already exists
   CUIERROR_CUSTOMMODE_OUT_OF_BW_LIMIT,			//The mode is exceeding the BW cap of the HW
   CUIERROR_CUSTOMMODE_INSUFFICIENT_MEMORY,		//Driver has insufficient memory to allocate for this mode
   CUIERROR_CUSTOMMODE_INVALID_LFP_RR,			//The specified RR is not supported on the LFP
   CUIERROR_MAX_ERROR							// Just a placeholder
};*/


#define E_NOTSUPPORTED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 201)

//CUI Operating Modes 
#define  CUIMODE_STANDARD     (1<<0)   //Single Display Single Device ( Single Pipe Single Device - to OS it is one display )
#define  CUIMODE_SPIPE_SIM    (1<<1)   //Single Display Dual Devices  ( Single Pipe dual Devices - to OS, it is one display )
#define  CUIMODE_MPIPE_SIM    (1<<2)   //Dual Display Dual Devices    ( Dual Pipe dual devices - to OS it is still one display )
#define  CUIMODE_MDS          (1<<3)   //Mutliple Display Systems     ( Extended Desktop Mode  - to OS, there are two displays) 

// CUI Device Types. There are possible 4 devices for each type
// Those devices are dynmically assigned 

#define CUIDEVICE_CRT1     0x01
#define CUIDEVICE_CRT2     0x02
#define CUIDEVICE_CRT3     0x04
#define CUIDEVICE_CRT4     0x08
#define CUIDEVICE_ALL_CRT (CUIDEVICE_CRT1 | CUIDEVICE_CRT2 | CUIDEVICE_CRT3 | CUIDEVICE_CRT4 )
#define CUIDEVICE_MULTI_CRT (CUIDEVICE_CRT2 | CUIDEVICE_CRT3 | CUIDEVICE_CRT4 )
//#define CUIDEVICE_CRT      CUIDEVICE_CRT1 

#define CUIDEVICE_TV1      (0x10) 
#define CUIDEVICE_TV2      (0x20)
#define CUIDEVICE_TV3      (0x40)
#define CUIDEVICE_TV4      (0x80)
#define CUIDEVICE_ALL_TV   (CUIDEVICE_TV1 | CUIDEVICE_TV2 | CUIDEVICE_TV3 | CUIDEVICE_TV4 )
#define CUIDEVICE_MULTI_TV   (CUIDEVICE_TV2 | CUIDEVICE_TV3 | CUIDEVICE_TV4 )
//#define CUIDEVICE_TV       CUIDEVICE_TV1

#define CUIDEVICE_DFP1     (0x100)   //Extennal DFP 
#define CUIDEVICE_DFP2     (0x200)
#define CUIDEVICE_DFP3     (0x400)
#define CUIDEVICE_DFP4     (0x800)
#define CUIDEVICE_ALL_DFP  (CUIDEVICE_DFP1 | CUIDEVICE_DFP2 | CUIDEVICE_DFP3 | CUIDEVICE_DFP4 )
#define CUIDEVICE_MULTI_DFP  (CUIDEVICE_DFP2 | CUIDEVICE_DFP3 | CUIDEVICE_DFP4 )
//#define CUIDEVICE_DFP      CUIDEVICE_DFP1

#define CUIDEVICE_LFP1     (0x1000)  //Internal LFP
#define CUIDEVICE_LFP2     (0x2000)
#define CUIDEVICE_LFP3     (0x4000)
#define CUIDEVICE_LFP4     (0x8000)
#define CUIDEVICE_ALL_LFP  (CUIDEVICE_LFP1 | CUIDEVICE_LFP2 | CUIDEVICE_LFP3 | CUIDEVICE_LFP4)
#define CUIDEVICE_MULTI_LFP  (CUIDEVICE_LFP2 | CUIDEVICE_LFP3 | CUIDEVICE_LFP4)
//#define CUIDEVICE_LFP      CUIDEVICE_LFP1
#define CUIDEVICE_ANYDEVICE (CUIDEVICE_ALL_CRT | CUIDEVICE_ALL_TV | CUIDEVICE_ALL_DFP | CUIDEVICE_ALL_LFP)
#define CUIDEVICE_MULTIDEVICE (CUIDEVICE_MULTI_CRT | CUIDEVICE_MULTI_TV | CUIDEVICE_MULTI_DFP | CUIDEVICE_MULTI_LFP)

#define CUIDEVICE_UNKNOWN  (1<<31)
#define CUIDEVICE_NULL     (0x10000)
#define CUIDEVICE_IGFX_ANY_TV	(1<<17) // for SDK use, when no TV is connected

#define NODEFAULT 0xffffffff
#define CUI_TVWIZARD_SUPPORTED 0x02

#define MAX_BUFFER_SIZE	2048
#ifdef _VISTA_
		//these two flags are required , because we have to send different values for
		// OS and Driver when setting a configuration
		#define INTERLACE	1 //RFVN path
		#define DM_INTERLACED 2 //OS CDS path
#endif


// Note:  Min, Max and Default are set by the CUIDriver for Read operations.
//        For Write operations into the CUI Driver, these are ignored.
typedef struct
{
   DWORD Value;
   DWORD Min;
   DWORD Max;
   DWORD Default;
}DWORDVALUE;

typedef struct
{
   CUIDriver_ERROR ErrorInfo;
   DWORD           dwDevice;      // A particular Type of device on that output.
   DWORDVALUE      Item;
} CUIDWORD, CUI_DWORD;

/******************************** CUIDEVICESTATE****************************/
/******************************** CUIDEVICESTATE****************************/
enum DEVICESTATE { NotSupported, Connected, NotConnected };
enum DEVICEPOWERSTATE { PowerUnknown, On, Off};
const GUID DeviceState= { 0x1a11f683, 0x1ccb, 0x11d3, { 0x91, 0x94, 0x0, 0x90, 0x27, 0x5c, 0x8a, 0x13} };
typedef struct
{
   CUIDriver_ERROR   ErrorInfo;
   DWORD             dwDevice;        // device type.
   enum DEVICESTATE  State;           // What is the connection state of this device.
   enum DEVICEPOWERSTATE  PowerState; // What is the power state of this device.
}CUIDEVICESTATE, CUI_DEVICESTATE_DATA;
/******************************** CUIDEVICESTATE****************************/
/******************************** CUIDEVICESTATE****************************/

/************************* ROTATION Interfaces Begin **********************/
// GUID for rotation enable/disable
// {FB9F312C-D7BF-40ea-80F9-F483A1C9DA22}
const GUID RotationEnabled =  { 0xfb9f312c, 0xd7bf, 0x40ea, { 0x80, 0xf9, 0xf4, 0x83, 0xa1, 0xc9, 0xda, 0x22 } };

const GUID Orientation =         { 0x3f0d2e85, 0xfbd5, 0x11d2, { 0x9c, 0x98, 0x0, 0x90, 0x27, 0x5c, 0x8a, 0x13 } };
// Rotation mask used to expose driver capability
// This corresponds to the value of szRotationCaps defined in registry.h
enum ROTATION_MASK
{
    ROTATION_MASK_90    =    0x0001,
    ROTATION_MASK_180    =    0x0002,
    ROTATION_MASK_270    =    0x0004
};
// Rotation value
// This is used from CUIDriver onwards to the top of the stack
typedef enum ROTATION_VALUE
{
    ROTATION_0           = 0x0000,
    ROTATION_90          = 0x0001,
    ROTATION_180         = 0x0002,
    ROTATION_270         = 0x0004
} ROTATIONTYPE;
// Rotation CUI data structure
// This is used from CUIDriver onwards to the top of the stack
typedef struct
{
   CUIDriver_ERROR ErrorInfo;
   DWORD           dwDevice;    // A Type of device on that output, only one device please
   DWORD dwSupportedRotations;  // Supported rotations, this is a bitmask
                                // Values are defined as folows:-
                                // ROTATION_MASK_90        -    90 degree
                                // ROTATION_MASK_180    -    180 degree
                                // ROTATION_MASK_270    -    270 degree

   DWORD dwCurrentRotation;        // Current rotation
                                // Values are defined as folows:-
                                // ROTATION_0    -    0 degree
                                // ROTATION_90    -    90 degree
                                // ROTATION_180    -    180 degree
                                // ROTATION_270    -    270 degree
} CUIROTATION;

// {8920DA72-B083-47c7-AAA9-E2C759582F8B}
static const GUID RotationPolicy = 
{ 0x8920da72, 0xb083, 0x47c7, { 0xaa, 0xa9, 0xe2, 0xc7, 0x59, 0x58, 0x2f, 0x8b } };

typedef struct _CUI_ROTATION_POLICY
{
    CUIDriver_ERROR  ErrorInfo;
    DWORD            dwDevice;   //Device type, only one device please, even in single pipe simultaneous mode
    DWORD            dwFlags;
    DWORD            dwPolicy;
}CUI_ROTATION_POLICY;

// dwPolicy can be one of this value
#define CUI_ROTATION_POLICY_DEFAULT        100
#define CUI_ROTATION_POLICY_INVERTED       101

// dwFlags can be one of this value
#define CUI_ROTATION_POLICY_FLAG_LANDSCAPE    (0x0001)
#define CUI_ROTATION_POLICY_FLAG_PORTRAIT     (0x0002)

/************************* ROTATION Interfaces End **********************/


/************************* CUI_EDID ****************************/
/************************* CUI_EDID ****************************/
const GUID gEDID = { 0x3cd22fbb, 0xe38c, 0x11d2, { 0x95, 0x88, 0x0, 0xa0, 0xc9, 0x56, 0xb2, 0x8 } };

// Structure definitions taken from VESA EDID document definition.
typedef struct _EDID_VERSION1_STRUCTURE
{
    unsigned char ucEDID_Header[8];
    unsigned char ucEDID_ProductInfo[10];
    unsigned char usEDID_EDIDVersion[2];
    unsigned char ucEDID_BasicParams[5];
    unsigned char ucEDID_ColorChars[10];
    unsigned char ucEDID_EstablishedRates[3];
    unsigned char ucEDID_StandardRates[16];
    unsigned char ucEDID_DetailedRates[72];
    unsigned char ucEDID_ExtensionFlag;
    unsigned char ucEDID_Checksum;
    unsigned char Unused[128];      // This here just so we can union this struct and the V2 struct.
}EDIDDATA_V1;

typedef struct _EDID_VERSION2_STRUCTURE
{
    unsigned char ucEDID_Ver;
    unsigned char ucEDID_VenProdID[7];
    unsigned char usEDID_MfgProdStr[32];
    unsigned char ucEDID_SerNum[16];
    unsigned char ucEDID_Reserved1[8];
    unsigned char ucEDID_DispIntfParams[15];
    unsigned char ucEDID_DispDevDesc[5];
    unsigned char ucEDID_DispRespTime[2];
    unsigned char ucEDID_ColorLumDesc[28];
    unsigned char ucEDID_DispSpatDesc[10];
    unsigned char ucEDID_Reserved2;
    unsigned char ucEDID_GTFSup;
    unsigned char ucEDID_MapOfTimingInfo[2];
    unsigned char ucEDID_LuminanceTblnTiming[127];
    unsigned char ucEDID_Checksum;
}EDIDDATA_V2;

// The driver may fill in an EDID V1 structure, or a V2 structure, which are different sizes
// and different byte definitions.  Here we define a single structure that will be used
// for EDID definition between the CUIDriver and higher level software.
// If the driver provides V1 data, we fill in that data and set the EDIDVersion member (see
// the CUI_EDID struct) with the appropriate version info to indicate V1 data.  Same idea for V2 data.
// See VESA Extended Display Identification Data (EDID) Proposal for definitions of structure elements.
typedef struct
{
   union
   {
      EDIDDATA_V1 V1Data;
      EDIDDATA_V2 V2Data;
   };
} EDID_DATA;

typedef struct
{
   CUIDriver_ERROR ErrorInfo;
   DWORD		dwDevice; 
   DWORD		dwEDIDBlock;
   WORD			EDIDVersion; // Version number in HIBYTE.  Minor Revision in LOBYTE.
   EDID_DATA	Edid;
}CUI_EDID;

#define VERSION_1 0x01
#define VERSION_2 0x02
/************************* CUI_EDID ****************************/
/************************* CUI_EDID ****************************/


/************************* CUIMEMINFO  **********************/
/************************* CUIMEMINFO  **********************/
// MemoryInfo: For DVMT memory
// {4124CBBE-6437-44f0-9F14-FF375AAFF166}
const GUID MemoryInfo = { 0x4124cbbe, 0x6437, 0x44f0, { 0x9f, 0x14, 0xff, 0x37, 0x5a, 0xaf, 0xf1, 0x66 } };
typedef struct
{
   CUIDriver_ERROR ErrorInfo;
   ULONG           PreAllocatedSize;       // pre-allocated memory size
   ULONG           MaxMemorySize;          // Maximum memory size: pre-allocated + DVMT 
   ULONG           UsedMemorySize;         // Currently In use memory: GMM allocated memory 
}CUIMEMINFO, CUI_MEMORYINFO_DATA, *PCUI_MEMORYINFO_DATA;

/************************* CUIMEMINFO  **********************/
/************************* CUIMEMINFO  **********************/


/************************* CUIBOOLEAN general values **********************/
/************************* CUIBOOLEAN general values **********************/
const GUID AdapterStatus =    { 0x1a11f681, 0x1ccb, 0x11d3, { 0x91, 0x94, 0x0, 0x90, 0x27, 0x5c, 0x8a, 0x13} };
//To reset CUICOM to initial state, Use CUIBOOLEAN for input, client does not have to setup anything
//   upon return, client could check CUIBOOLEAN::Value to see whether it is successiful( normally willl ), If 
//   the function fails, clients should unload CUICOM and load CUICOM again 
//          {AF886AB8-EBA3-450b-8926-2104F56B5A8C}
static const GUID ResetCOM =  { 0xaf886ab8, 0xeba3, 0x450b, { 0x89, 0x26, 0x21, 0x4, 0xf5, 0x6b, 0x5a, 0x8c } };

// Aspect Scaling RCR - Change Start
/********************************* CUIMULTIDWORD *********************************/
/********************************* CUIMULTIDWORD *********************************/

const GUID DisplayCompensation =  { 0xbbd4bc1, 0xb805, 0x11d5, { 0xb0, 0x75, 0x0, 0x3, 0x47, 0x68, 0x1b, 0x6 } };

typedef struct
{
   CUIDriver_ERROR ErrorInfo;
   DWORD dwDevice;      // A particular Output and Type of device on that output.
   DWORD Item1;
   DWORD Item2;
}CUIMULTIDWORD;

/********************************* CUIMULTIDWORD *********************************/
/********************************* CUIMULTIDWORD *********************************/

// Aspect Scaling RCR - Change End

// {598E6B6F-D863-41ee-9A2D-CC4A5BDD4D58}
const GUID RegRefreshRate = { 0x598e6b6f, 0xd863, 0x41ee, { 0x9a, 0x2d, 0xcc, 0x4a, 0x5b, 0xdd, 0x4d, 0x58 } };

typedef struct
{
   CUIDriver_ERROR ErrorInfo;
   DWORD           dwDevice; 
   BOOLEAN         Value;
}CUIBOOLEAN, CUI_BOOLEAN;

/************************* CUIBOOLEAN general values **********************/
/************************* CUIBOOLEAN general values **********************/

/************************ CUIBSTR general values **********************/
const GUID SelectDeviceContext = { 0xc7093561, 0xee8b, 0x11d2, { 0x95, 0x88, 0x0, 0xa0, 0xc9, 0x56, 0xb2, 0x8 } };
const GUID VBiosVersion =        { 0x3cd22fb0, 0xe38c, 0x11d2, { 0x95, 0x88, 0x0, 0xa0, 0xc9, 0x56, 0xb2, 0x8 } };

typedef struct
{
   CUIDriver_ERROR ErrorInfo;
   BSTR Value;                  //BSTR of version info. i.e, version 3267 will be BSTR of L'3267'
                                //Caller must release memory by using ::SysFreeString(CUI_BSTR::Value)
}CUIBSTR, CUI_BSTR;
/************************* CUIBSTR general values **********************/
/************************* CUIBSTR general values **********************/


/************************* Overlay GAMMA **********************/
/************************* Overlay GAMMA **********************/
const GUID OverlayGamma    =  { 0x2d5d9042, 0x8e0a, 0x11d3, { 0xa7, 0xbf, 0x0, 0xa0, 0xc9, 0xad, 0x55, 0xaf } };

enum OverlayColorAttribute
{
    Overlay_All = 0,
    Overlay_Brightness,
    Overlay_Contrast,
    Overlay_Gamma,
    Overlay_Saturation,
	Overlay_Hue
};

enum OverlayColorFlags
{
    SetToRegistry = 1,
    SetToHardware,
    GetFromRegistry,
    GetFromHardware,
    GetOEMDefaultsFromRegistry
};

typedef struct
{
   CUIDriver_ERROR     ErrorInfo;
                           // valid range.   Default value
   DWORD Brightness;       // 0-10000           750
   DWORD Contrast;         // 0-20000           10000
   DWORD Gamma;            // 1-500             1
   DWORD Saturation;       // 0-20000           10000
   DWORD Hue;				// -90 to 90
   enum OverlayColorAttribute eOverlayColorAttribute;
   enum OverlayColorFlags eOverlayColorFlags;
}CUIOVERLAY_COLOR;
/************************* Overlay GAMMA **********************/
/************************* Overlay GAMMA **********************/


/************************* GAMMA **********************/
/************************* GAMMA **********************/
const GUID Gamma =            { 0x3cd22fb2, 0xe38c, 0x11d2, { 0x95, 0x88, 0x0, 0xa0, 0xc9, 0x56, 0xb2, 0x8 } };
typedef struct
{
   unsigned short Red[256];
   unsigned short Green[256];
   unsigned short Blue[256];
}GAMMA_BUFFER;          // read/write, DAC gamma values


typedef struct
{
   CUIDriver_ERROR      ErrorInfo;
   DWORD                dwDevice; 
   GAMMA_BUFFER         Gamma;
}GAMMA_BUFFER_WERROR;
/************************* GAMMA **********************/
/************************* GAMMA **********************/


/************************* CUIREFRATE_WERROR **********************/
/************************* CUIREFRATE_WERROR **********************/
#define MAX_CUI_REF_RATES                 20
#define PRIMARY_REFRATE_FLAG	1
#define SECONDARY_REFRATE_FLAG	2
typedef struct
{
    int   iWidth;
    int   iHeight;
    int   iBpp;
} CUIRESOLUTION;

typedef struct
{
    WORD        rrRefreshRate;                    // Refresh rate (in Hertz)
} CUIREF_RATE, *PCUIREF_RATE;

typedef struct
{
    WORD                   rrlNumRefRates;                  // Number of refresh rates in list
    CUIREF_RATE            rrlRefRates[MAX_CUI_REF_RATES];  // List of refresh rates
} CUIREF_RATE_LIST;

typedef struct
{
   CUIDriver_ERROR ErrorInfo;
   DWORD           dwDevice;
   CUIRESOLUTION ResParams;                // for win 95 use only
   CUIREF_RATE_LIST RefRateList;    // No point in this being a pointer
   DWORD dwRefreshRateFlags;        //Use PRIMARY_REFRATE_FLAG or SECONDARY_REFRATE_FLAG
}CUIREFRATE_WERROR;
/************************* CUIREFRATE_WERROR **********************/
/************************* CUIREFRATE_WERROR **********************/


/************************* CUIDEVICEMODE2_WERROR*******************/ 
// {EC111B17-95D6-48ff-84E8-DF17BCD9D8A7}

#define MAX_CUI_VIDEO_MODES                 1000  //We may need more than this

typedef struct
{
    WORD  vmHzRes;                     // Horizontal resolution (in pixels)
    WORD  vmVtRes;                     // Vertical resolution (in pixels)
    WORD  vmRefreshRate;               // Refresh rate (in Hertz)
    WORD  vmPixelDepth;                // 26:add
	DWORD dwSupportedStandard;
	DWORD dwPreferredStandard;
	WORD  InterlaceFlag;//added this because when we query we need to know whether its interlaced or not.
} CUIVIDEO_MODE, *PCUIVIDEO_MODE;

typedef struct
{
    WORD           vmlNumModes;                // Number of video modes in list
    CUIVIDEO_MODE  vmlModes[MAX_CUI_VIDEO_MODES];  // List of video modes
} CUIVIDEO_MODE_LIST;

//Note, DeviceModeList and DeviceModes are the same, DeviceModeList are more meaningful for this 
//      function
static const GUID DeviceModeList = { 0xec111b17, 0x95d6, 0x48ff, { 0x84, 0xe8, 0xdf, 0x17, 0xbc, 0xd9, 0xd8, 0xa7 } };
#define  CUIDEVICEMODELIST_MODEINFO_FOR_PRIMARY    0x01  //FixedMode is for primary, asking for secondary mode list
#define  CUIDEVICEMODELIST_MODEINFO_FOR_SECONDARY  0x02  //Fixed mode is for secondary, asking for primary mode list

static const GUID DeviceModes = { 0xec111b17, 0x95d6, 0x48ff, { 0x84, 0xe8, 0xdf, 0x17, 0xbc, 0xd9, 0xd8, 0xa7 } };
#define  CUIDEVICEMODE_MODEINFO_FOR_PRIMARY_DISPLAY    0x01 //FixedMode is for primary, asking for secondary mode list
#define  CUIDEVICEMODE_MODEINFO_FOR_SECONDARY_DISPLAY  0x02 //Fixed mode is for secondary, asking for primary mode list
typedef  struct { 
   CUIDriver_ERROR ErrorInfo;
   DWORD           dwFlags; 
   DWORD           dwOperatingMode;    //Set CUI Operating Mode of interest
   DWORD           dwPrimaryDevices;   //Set CUIDevices of primary display( for SinglePipeSimultaneous mode, both devices must be here )
   DWORD           dwSecondaryDevices; //Set CUIDevices of secondary display 
   CUIVIDEO_MODE   FixedMode;          //The intended display mode on one display
                                       //dwFlag is going to tell for which display it is
                                       //used for
   CUIVIDEO_MODE_LIST VidModeList;

} CUIDEVICEMODE_WERROR, CUI_DeviceModeList_DATA, CUI_DEVICE_MODE_LIST_DATA, *PCUI_DEVICE_MODE_LIST_DATA; 

/************************* CUIDEVMODE_WERROR2 *********************/


/*************************** LID_SMIHotkeystatus *************************/
static const GUID NextToggleDevice = { 0xe75d0a77, 0xcb22, 0x439c, { 0x91, 0xb1, 0xf2, 0x7a, 0xa6, 0x1d, 0xf1, 0xcf } };
// {105E4D36-A3D9-4067-89F8-F1C253091993}
static const GUID LidSMIHotkeyStatus = { 0x105e4d36, 0xa3d9, 0x4067, { 0x89, 0xf8, 0xf1, 0xc2, 0x53, 0x9, 0x19, 0x93 } };
typedef struct { 
    CUIDriver_ERROR         ErrorInfo; 
    DWORD                   dwStatusChanged;  //1: Changed, 0 Not changed
} CUI_LIDSMIHOTKEYSTATUS_DATA, CUI_LID_SMIHOTKEY_STATUS_DATA, *PCUI_LID_SMIHOTKEY_STATUS_DATA; 
/*************************** End of LID_SMIHotkeystatus *************************/

/*************************** CUI_OPENGL_PROPERTIES *************************/
// Internal structures used
typedef struct
{
   DWORD Value;
   DWORD Default;
}DWORD_PAIR;
typedef struct
{
    BOOLEAN Value;
    BOOLEAN Default;
}BOOLEAN_PAIR;
// Bits identifying a specific property
#define    CUI_OPENGL_ASYNCFLIP                    1<<0
#define    CUI_OPENGL_TRIPLEBUFFERING                1<<1
#define    CUI_OPENGL_FLIPPOLICY                    1<<2
#define    CUI_OPENGL_DEPTHBUFFERBITDEPTH            1<<3
#define    CUI_OPENGL_FORCES3TC                    1<<4
#define    CUI_OPENGL_FORCEFXT1                    1<<5
#define    CUI_OPENGL_DRIVERMEMORYFOOTPRINT        1<<6
#define    CUI_OPENGL_TEXTURECOLORDEPTH            1<<7
#define    CUI_OPENGL_ANOSOTROPICFILTERING            1<<8

// Property specific defines
#define CUI_OPENGL_TRIPLEBUFFERING_DEFAULT                -1
#define CUI_OPENGL_TRIPLEBUFFERING_OFF                    0
#define CUI_OPENGL_TRIPLEBUFFERING_ON                    1
#define CUI_OPENGL_FLIPPOLICY_FLIP                        TRUE
#define CUI_OPENGL_FLIPPOLICY_BLIT                        FALSE
#define CUI_OPENGL_DEPTHBUFFERBITDEPTH_DEFAULT            0
#define CUI_OPENGL_DEPTHBUFFERBITDEPTH_16                16
#define CUI_OPENGL_DEPTHBUFFERBITDEPTH_24                24
#define CUI_OPENGL_DRIVERMEMORYFOOTPRINT_NORMAL            2
#define CUI_OPENGL_DRIVERMEMORYFOOTPRINT_LOW            1
#define CUI_OPENGL_DRIVERMEMORYFOOTPRINT_HIGH            0
#define CUI_OPENGL_TEXTURECOLORDEPTH_DESKTOPCOLORDEPTH    0
#define CUI_OPENGL_TEXTURECOLORDEPTH_16BPT                16
#define CUI_OPENGL_TEXTURECOLORDEPTH_32BPT                32
#define CUI_OPENGL_ANOSOTROPICFILTERING_APPCONTROL        -1    // Need to find out from Bimal
#define CUI_OPENGL_ANOSOTROPICFILTERING_OFF                0    // Need to find out from Bimal
#define CUI_OPENGL_ANOSOTROPICFILTERING_ON                1    // Need to find out from Bimal
const GUID OpenGLProperties = { 0x698a0cf0, 0x110d, 0x4478, { 0xa0, 0x32, 0x94, 0x87, 0xaa, 0xd2, 0xdc, 0xc9 } };
// OPENGL structure USED FOR Service<->CUICOM interaction
typedef struct
{
    CUIDriver_ERROR ErrorInfo;
    
    DWORD  dwDevice;      //For which device we are talking about[IN]
    // Bit mask indicating the supported properties
    DWORD dwSupportedProperties;

    // Properties/attributes
    BOOLEAN_PAIR bAsyncFlip;
    DWORD_PAIR bTripleBuffering;
    BOOLEAN_PAIR bFlipPolicy;
    DWORD_PAIR dwDepthBufferBitDepth;
    BOOLEAN_PAIR bForceS3TCTextureCompression;
    BOOLEAN_PAIR bForceFXT1TextureCompression;
    DWORD_PAIR dwDriverMemoryFootprint;
    DWORD_PAIR dwTextureColorDepth;
    DWORD_PAIR dwAnosotropicFiltering;    
}CUI_OPENGL_PROPERTIES;
/*************************** End of CUI_OPENGL_PROPERTIES *************************/

/*************************** CUI_POWERSTATE *************************/
// {79643B2E-1A67-493e-960D-125AEA791F36}
const GUID PowerState = { 0x79643b2e, 0x1a67, 0x493e, { 0x96, 0xd, 0x12, 0x5a, 0xea, 0x79, 0x1f, 0x36 } };

#define CUI_POWERSTATE_DC                        1<<0
#define CUI_POWERSTATE_AC                        1<<1
#define CUI_POWERSTATE_AC_DC                     (CUI_POWERSTATE_AC | CUI_POWERSTATE_DC)

typedef struct
{
    CUIDriver_ERROR ErrorInfo;

    DWORD dwSupportedStates;    /* OUT - combination of the CUI_POWERSTATE_* bits*/
    DWORD dwCurrentState;        /* OUT - combination of the CUI_POWERSTATE_* bits*/
}CUI_POWERSTATE, *PCUI_POWERSTATE;
/*************************** End of CUI_POWERSTATE *************************/


/********************************FP Refresh Rate: RCR192818********************/
// {69D495C5-6069-4b75-9688-400DA3EE7AE3}
const GUID DeviceRefreshRates = { 0x69d495c5, 0x6069, 0x4b75, { 0x96, 0x88, 0x40, 0xd, 0xa3, 0xee, 0x7a, 0xe3 } };
typedef struct
{
    CUIDriver_ERROR  ErrorInfo;
    DWORD            dwDevice; 
    CUIREF_RATE_LIST RefreshRates;      // List of refresh rates 
    BOOLEAN          GetCurrentRefreshRate;  // If TRUE, return current refresh rate set on the device
                                        // else return the list of supported refresh rates by the device. 
}CUI_DEVICE_REFRESHRATES;

/********************************FP Refresh Rate END**************************/

/********************************DisplayParameters: RCR192818********************/
// {E148F169-BE11-4c64-988C-E837E8920631}
const GUID DisplayParameters = { 0xe148f169, 0xbe11, 0x4c64, { 0x98, 0x8c, 0xe8, 0x37, 0xe8, 0x92, 0x6, 0x31 } };
typedef struct
{
    CUIDriver_ERROR     ErrorInfo;
    DWORD               dwDevice;              // [IN]Display Device.

    DWORD               dwFlags;

    UINT                nPhysicalWidth;
    UINT                nPhysicalHeight;
	UINT				nDisplayWidth;
	UINT				nDisplayHeight;
    
    BOOLEAN             bScalingEnabled;

    POINT               ptViewPort;
}CUI_DEVICE_PARAMETERS, CUI_DISPLAYPARAMETERS_DATA;
// Definition of dwFlags
#define CUI_DEVICE_PARAMETERS_PHYSICAL        1<<0
#define CUI_DEVICE_PARAMETERS_SCALING         1<<1
#define CUI_DEVICE_PARAMETERS_VIEWPORT        1<<2
#define CUI_DEVICE_PARAMETERS_DISPLAY         1<<3

/********************************DisplayParameters END**************************/

/********************************SystemNotify: RCR211726********************/
// {632149ED-A911-4de9-8ABE-2E5D89A24F50}
const GUID SystemNotify = { 0x632149ed, 0xa911, 0x4de9, { 0x8a, 0xbe, 0x2e, 0x5d, 0x89, 0xa2, 0x4f, 0x50 } };
typedef struct
{
    CUIDriver_ERROR  ErrorInfo;

    BOOLEAN bPrimaryBootDisplayPreference;
}CUI_SYSTEMNOTIFY_PARAMETERS;
/********************************DisplayParameters END**************************/


/**********************************AtomicI2C Start*****************************/
//RCR224345. Data Structure is same as I2C, refer to I2C for details
// {1B9FD916-DA16-4a51-AFBE-8FA712FBB5CE}
static const GUID AtomicI2C = { 0x1b9fd916, 0xda16, 0x4a51, { 0xaf, 0xbe, 0x8f, 0xa7, 0x12, 0xfb, 0xb5, 0xce } };
enum CUII2CBUS
{
   DDCBUS = 0,    // BUS 0 - going to analog VGA connector
   I2CBUS,        // BUS 1 - going to other peripherals
                  //         (FP, TMDS, Tuner, Capture, etc.)
};
typedef struct
{
    enum CUII2CBUS  bus;
    DWORD   dev;
    DWORD   SubAddr;
    DWORD   dwFlags;
    DWORD   dwWriteBytes;
    DWORD   dwReadBytes;
    BYTE    bData[130];    // Source Addr byte + leng byte + message len (127 bytes) + checksum byte
                        // 1 + 1 + 127 + 1 = 130
}CUII2C;

//XXX:...More discussion is necessary on this one
enum CUII2CFLAGS {
    i2cf_Init            = 1<<0,
    i2cf_DevValid        = 1<<1,
    i2cf_SubAddrValid    = 1<<2,
    i2cf_ResultsExpected = 1<<3
};

typedef struct
{
   CUIDriver_ERROR ErrorInfo;
   DWORD           dwDevice; 
   CUII2C         Value;
}CUII2C_WERROR;
/**********************************AtomicI2C End*******************************/

// {28A83F3E-4046-480a-9CCF-4B1F20440091}
static const GUID GraphicsFamilyName ={ 0x28a83f3e, 0x4046, 0x480a, { 0x9c, 0xcf, 0x4b, 0x1f, 0x20, 0x44, 0x0, 0x91 } };
typedef enum _CHIPSET_FAMILY
{
    CHIPSET_FAMILY_UNKNOWN,
    CHIPSET_FAMILY_ALMADOR_M,
    CHIPSET_FAMILY_BROOKDALE_G,
    CHIPSET_FAMILY_MONTARAG_M,
    CHIPSET_FAMILY_SPRINGDALE_G,
    CHIPSET_FAMILY_GRANTSDALE_G, 
    CHIPSET_FAMILY_ALVISO_G,
    CHIPSET_FAMILY_LAKEPORT_G,
	CHIPSET_FAMILY_CALISTOGA_G,
	CHIPSET_FAMILY_BROADWATER_G,
	CHIPSET_FAMILY_CRESTLINE_G,
	CHIPSET_FAMILY_BEARLAKE_B,
	CHIPSET_FAMILY_CANTIGA,
	CHIPSET_FAMILY_EAGLELAKE,
	CHIPSET_FAMILY_IRONLAKE_DESKTOP,
	CHIPSET_FAMILY_IRONLAKE_MOBILE

}CHIPSET_FAMILY, GRAPHICS_FAMILY;
typedef   struct { 
    CUIDriver_ERROR  ErrorInfo;
    GRAPHICS_FAMILY  eFamilyName;           //Chipset/family Name, see above definition 
    WORD             wRevision;             //Chip Revision --- Not Used at the moment 
    WORD             wReserved;             //Reserved for later use -- ( function number )
} CUI_GRAPHICS_FAMILY_NAME, *PCUI_GRAPHICS_FAMILY_NAME; 


//ZoomOptions:  to report dual view zoom setting in VBT. The purpose is to enable PC14 Zoom application button on 
//              CUI --- If VBT Zoom is enabled, button is shown, otherwise it is hidden. 
//{CD9E5649-3B06-4b81-801D-0C45DDAD7D6C}
static const GUID ZoomOption = { 0xcd9e5649, 0x3b06, 0x4b81, { 0x80, 0x1d, 0xc, 0x45, 0xdd, 0xad, 0x7d, 0x6c } };
typedef struct  { 
    CUIDriver_ERROR     ErrorInfo;       
    DWORD               dwOption;   // 0 --- Disabled in VBT 
                                    // 1 --- Enabled in VBT 
                                    // Other values: reserved for future extension
} CUI_ZOOM_OPTION, *PCUI_ZOOM_OPTION; 

//Lakeport New Add-ins 
// {44232C3B-4C8D-4277-A199-64E809EFD130}
static const GUID DetectDevice ={ 0x44232c3b, 0x4c8d, 0x4277, { 0xa1, 0x99, 0x64, 0xe8, 0x9, 0xef, 0xd1, 0x30 } };
#define CUI_DETECTDEVICE_DO_LEGACY_CRT_DETECT  0x01
#define CUI_DETECTDEVICE_DO_ACTIVE_DETECTION   0x02
typedef struct { 
    CUIDriver_ERROR     ErrorInfo; 
    DWORD               dwFlags;            //Device Detect Features, See above
    DWORD               dwAttachedDevices;  //Detected Attached Devices 
    DWORD               dwPriDev;           //Devices Currently connected to primary display 
    DWORD               dwSecDev;           //Device  currently connecte to secondary display
} CUI_DETECT_DEVICE, *PCUI_DETECT_DEVICE; 


// {455EC29B-0A17-41e0-9DEE-31C3D9643D73}
static const GUID DriverVersionInfo ={ 0x455ec29b, 0xa17, 0x41e0, { 0x9d, 0xee, 0x31, 0xc3, 0xd9, 0x64, 0x3d, 0x73 } };
typedef struct { 
    CUIDriver_ERROR     ErrorInfo;
    DWORD               dwMajor;   //Major Version 
    DWORD               dwMinor;   //Minor Version
}DRIVER_VERSIONINFO_DATA, *PDRIVER_VERSION_INFO; 

// {5E6AFE47-6257-43a3-B6BF-51DFDF96FCD7}
static const GUID CurSysConfig = { 0x5e6afe47, 0x6257, 0x43a3, { 0xb6, 0xbf, 0x51, 0xdf, 0xdf, 0x96, 0xfc, 0xd7 } };
typedef CUIVIDEO_MODE CUI_VIDEO_MODE, *PCUI_VIDEO_MODE; 
typedef struct {     
    BOOL  bIsHDTV;
	DWORD dwDisplayDev;   //Display Device(s) for this display 
	DWORD dwTvStandard;
#ifdef _VISTA_
	DWORD dwFlags;
	DWORD dwTvFormat; // TV Format Policy
	DWORD dwAvbStandard;
	DWORD dwOverScanX;
	DWORD dwOverScanY;
#endif
    CUI_VIDEO_MODE  Resolution;     //Display Mode for this display
	int iLeft;
	int iRight;
	int iTop;
	int iBottom;
} CUI_DISPLAY_CONFIG, *PCUI_DISPLAY_CONFIG; 
typedef struct { 
    CUIDriver_ERROR     ErrorInfo; 
    DWORD               dwOpMode;   //System Operating Mode: CUIMODE_STANDARD
                                    //                       CUIMODE_SPIPE_SIM
                                    //                       CUIMODE_MPIPE_SIM
                                    //                       CUIMODE_MDS
    CUI_DISPLAY_CONFIG  PriDispCfg; //configuration on primary display -- device and display mode 
    CUI_DISPLAY_CONFIG  SecDispCfg; //configuration on secondary display
#ifdef _VISTA_
	DWORD dwPrimRot;
	DWORD dwSecRot;
	DWORD dwPrimAspectOption;
	DWORD dwPrimCurrentXX;
	DWORD dwPrimCurrentYY;
	DWORD dwSecAspectOption;
	DWORD dwSecCurrentXX;
	DWORD dwSecCurrentYY;
	BOOL  bIsInvOptimizationReqd;
#endif
} CUI_SYSTEM_CONFIG, *PCUI_SYSTEM_CONFIG; 


static const GUID TestConfig =       { 0x196fa5a2, 0x45ed, 0x11d4, { 0xb5, 0x61, 0x0, 0xa0, 0xc9, 0x2e, 0x68, 0x48 } };
#define     CUI_TESTCONFIG_FOR_STANDARD_MODE  0x01      //Ask for Standard Mode only
#define     CUI_TESTCONFIG_FOR_SPIPE_SIM_MODE 0x02      //Ask for dualview twin mode 
#define     CUI_TESTCONFIG_FOR_MPIPE_SIM_MODE 0x04      //Ask for dualview twin plus 
#define     CUI_TESTCONFIG_FOR_MDS            0x08      //Ask for Extended desktop mode 

#define     CUI_TESTCONFIG_FOR_ALL            0x0F      //Ask for all modes mentioned above
#define     MAX_TEST_CONFIGURATION            96		//For six devices it will be 6 + 3 * P(6,2)


typedef struct { 
    DWORD       dwOperatingMode;
    DWORD       dwPriDev; 		//Device on Primary Display( For Single Pipe Simultaneous mode, both devices are here )
    DWORD       dwSecDev; 		//Device on Secondary Display
} DEVICE_CONFIG_DATA; 
typedef struct { 
	CUIDriver_ERROR	ErrorInfo; 
    DWORD           dwFlags;           //Requested Mode flags, see above please    
    DWORD 			dwAvailDev;        //Given Display Devices

    DWORD 			dwTotal;            //Total of validation configuration in 
						                // the following array 
    DEVICE_CONFIG_DATA  ConfigList[MAX_TEST_CONFIGURATION]; //Valid device combinations; for 4 devices, max possible number is 40
                                        //So 64 should be enough for now
} CUI_TEST_CONFIG, *PCUI_TEST_CONFIG;

// {014C0B8B-8642-4dc5-AC0F-888C991A329D}
static const GUID ValidateSysConfig = { 0x14c0b8b, 0x8642, 0x4dc5, { 0xac, 0xf, 0x88, 0x8c, 0x99, 0x1a, 0x32, 0x9d } };
typedef struct { 
    CUIDriver_ERROR     ErrorInfo; 
    DWORD               dwOpMode;   //System Operating Mode: CUIMODE_STANDARD
                                    //                       CUIMODE_SPIPE_SIM
                                    //                       CUIMODE_MPIPE_SIM
                                    //                       CUIMODE_MDS
    CUI_DISPLAY_CONFIG  PriDispCfg; //configuration on primary display -- device and display mode 
    CUI_DISPLAY_CONFIG  SecDispCfg; //configuration on secondary display
    BOOL                bStatus;    //Validate Result: TRUE -- Supportable, FALSE -- not supportable
} CUI_VALIDATE_SYSTEM_CONFIG, *PCUI_VALIDATE_SYSTEM_CONFIG; 

// {B6523540-4D2B-404e-94A9-4095AB24A3B0}
static const GUID PowerConservation =  { 0xb6523540, 0x4d2b, 0x404e, { 0x94, 0xa9, 0x40, 0x95, 0xab, 0x24, 0xa3, 0xb0 } };
#define CUI_POWER_FBC   0x01
#define CUI_POWER_GSV   0x02
#define CUI_POWER_CXSR   0x04
#define CUI_POWER_DPST   0x08
#define CUI_POWER_ALS   0x10
#define CUI_POWER_SRD   0x20 
#define CUI_POWER_DPS   0x40
#define CUI_POWER_GRS   0x80
#define CUI_POWER_FEATURE_SETTINGS			0x01 // Feature Setting operation
#define CUI_POWER_BACKLIGHT_SETTINGS	0x02 // Applications Backlight Setting operation
#define CUI_POWER_PLAN_SETTINGS		0x03 // Power Plan Setting operation
/*the enum for different power plans*/
typedef enum CUI_POWER_PLAN_ENUM
{
	CUIPWR_PLAN_GET_CURRENT,
    CUIPWR_PLAN_BEST_POWER_SAVINGS,    
    CUIPWR_PLAN_BETTER_POWER_SAVINGS,  
    CUIPWR_PLAN_GOOD_POWER_SAVINGS,    
    CUIPWR_PLAN_DISABLE_POWER_SAVINGS, 
    CUIPWR_PLAN_CUSTOM,                
    CUI_NUM_OF_PWR_USER_PLANS
} CUI_POWER_PLAN;
typedef   struct { 
    CUIDriver_ERROR     ErrorInfo; 
    DWORD               dwPowerState;       //Should be CUI_POWERSTATE_DC/CUI_POWERSTATE_AC, currently we support for DC only
	DWORD               dwOperation;		//To mention whether set backlit, power plan or feature setting
	CUI_POWER_PLAN      PowerPlan;		    //The predefined power plan
    DWORD               dwDisplayDevice;    //Display Device, set for LFP Only 
    union { 
        DWORD           dwCapability;       //For Get, Capability -- features we are supporting in driver
        DWORD           dwChangedFeatures;  //For Set, Features CUI wants to change, values are in dwEnabledFeature
    };
    DWORD               dwEnabledFeatures;  //Current Status -- enabled features 
	DWORD               dwDPSTCurLevel;      //DPST Level, Current Level and Supported MAX Level 
    DWORD               dwDPSTTotalLevel; 
    
	DWORD               dwGSVCurLevel;      //Graphics P State Level, Current Level and Supported MAX Level 
    DWORD               dwGSVTotalLevel;

    BOOL				bIsMFD;			//Whether MFD is supported or not
	BOOL				IsSupportForStaticDRRS; // Static DRRS RCR enabled for Vista 1022287
	DWORD				dwRR[20];  //Refresh rate array
	DWORD				dwLowRR;	//Current low RR
	DWORD				dwNumRR;	//Number of refresh rates
} CUI_POWER_CONSERVATION_DATA, *PCUI_POWER_CONSERVATION_DATA; 


// {99EDE439-9FE8-46f6-8345-686AD45098E7}
static const GUID PersistOptions = { 0x99ede439, 0x9fe8, 0x46f6, { 0x83, 0x45, 0x68, 0x6a, 0xd4, 0x50, 0x98, 0xe7 } };
#define CUI_POWER_PERSIST	     (1<<0 )  //Persist display configuration in case of power event
#define CUI_LID_PERSIST          (1<<1 )  //Persist display configuration in case of lid event 
#define CUI_HOTKEY_PERSIST       (1<<2 )  //Persist display configuration in case of hotkey event
#define CUI_HOTPLUG_PERSIST      (1<<3 )  //Persist display configuration in case of hotplug event

#define CUI_MDS_DDC_PERSIST      (1<<4 )   //MDS Persist. Decides should system get into MDS in case of hotkey event
#define CUI_EDID_PERSIST         (1<<5 )   //Use EDID to do persistence for devices
#define CUI_REFRATE_PERSIST      (1<<6 )   //Refresh Rate Persist -- for hotkey
#define CUI_PIPE_PERSIST         (1<<7 )   //Pipe Persist -- for hotkey not sure it is useful to CUI at all
#define CUI_MODE_PERSIST         (1<<8 )   //Mode persist -- for hotkey
#define CUI_HOT_DOCUNDOC_PERSIST (1<<9 )	 // Hot Doc Undoc Persistence	

typedef struct { 
    CUIDriver_ERROR ErrorInfo;
    DWORD dwPersistFeatures;  //Bit OR of above defined features
    DWORD dwMaxEdidPersist;   //Valid only when EDID persist(CUI_EDID_PERSIST) is enabled
} CUI_PERSIST_OPTIONS_DATA, *PCUI_PERSIST_OPTIONS_DATA, 
  CUI_PERSIST_OPTIONS, *PCUI_PERSIST_OPTIONS;

// {174D202F-9DAE-4e88-A3E2-0427517362C7}
static const GUID DriverEvent =  { 0x174d202f, 0x9dae, 0x4e88, { 0xa3, 0xe2, 0x4, 0x27, 0x51, 0x73, 0x62, 0xc7 }};
#define  COMMAND_REGISTER_EVENT     0x01
#define  COMMAND_UNREGISTER_EVENT   0x02
typedef enum { 
    CUI_EVENT_TYPE_HOTKEY = 0,
    CUI_EVENT_TYPE_LIDSWITCH, 
    CUI_EVENT_TYPE_HOTPLUG,
	CUI_EVENT_TYPE_HOTDOCUNDOC,

    CUI_EVENT_TYPE_MAX,
} CUI_DRIVER_EVENT_TYPE; 

typedef struct
{
   CUIDriver_ERROR	                ErrorInfo;
   DWORD                            dwCommand; //COMMAND_REGISTER_EVENT, COMMAND_UNREGISTER_EVENT
   CUI_DRIVER_EVENT_TYPE     		eEventType; //Type of Event
   #ifdef WIN64
		HANDLE_PTR	                    hEvent;  // Handle of the event
   #else
		HANDLE	                    hEvent;  // Handle of the event
   #endif
}CUI_DRIVER_EVENT_DATA, *PCUI_REGISTER_EVENT_DATA;



//TV Control Interfaces
//1. StdTVControl: for SoftBios Standard TV Control Paramter, which controls the following: 
//      X  Position 
//      Y  Posistion 
//      X  Size
//      Y  Size
//      Brightness 
//      Contrast 
//      Flicker
// {2C26F588-B60F-4265-9EAA-13DB8CCE0222}
static const GUID StdTVControl = { 0x2c26f588, 0xb60f, 0x4265, { 0x9e, 0xaa, 0x13, 0xdb, 0x8c, 0xce, 0x2, 0x22 } };
typedef struct
{
    DWORD           dwValue;    //Current Value
    DWORD           dwDefault;  //Default Value 
    DWORD           dwMin;      //Minimium Value 
    DWORD           dwMax;      //Maximium Value 
    DWORD           dwStep;     //Adjustment value for each step
}CUI_EXTV_DATA, *PCUI_EXT_TV_DATA;
#define  CUI_STDTV_FLAG_POSITIONX       0x01
#define  CUI_STDTV_FLAG_POSITIONY       0x02
#define  CUI_STDTV_FLAG_SIZEY           0x04
#define  CUI_STDTV_FLAG_SIZEX           0x08
#define  CUI_STDTV_FLAG_BRIGHTNESS      0x10
#define  CUI_STDTV_FLAG_CONTRAST        0x20 
#define  CUI_STDTV_FLAG_FLICKER         0x40
typedef struct { 
    CUIDriver_ERROR ErrorInfo; 
    DWORD           dwDevice;    //TV Display Device
    DWORD           dwFlags;    //Controlling features, OR of all supported features 
    CUI_EXTV_DATA   PositionX;  
    CUI_EXTV_DATA   PositionY; 
    CUI_EXTV_DATA   SizeX; 
    CUI_EXTV_DATA   SizeY; 
    CUI_EXTV_DATA   Brightness; 
    CUI_EXTV_DATA   Contrast; 
    CUI_EXTV_DATA   Flicker; 
} CUI_STD_TV_CONTROL_DATA, *PCUI_STD_TV_CONTROL_DATA, CUI_STDTVCONTROL_DATA; 
// {8ACC53AC-92CB-4315-BAE0-ED0F12AE8AF5}
static const GUID ExtTVControl = { 0x8acc53ac, 0x92cb, 0x4315, { 0xba, 0xe0, 0xed, 0xf, 0x12, 0xae, 0x8a, 0xf5 } };
#define CUI_EXTV_FLAG_SHARPNESS					0x01
#define CUI_EXTV_FLAG_ADAPTIVEFLICKER			0x02
#define CUI_EXTV_FLAG_TWODFLICKER				0x04
#define CUI_EXTV_FLAG_SATURATION				0x08
#define CUI_EXTV_FLAG_HUE						0x10
#define CUI_EXTV_FLAG_DOTCRAWL					0x20
#define CUI_EXTV_FLAG_LUMAFILTER				0x40 
#define CUI_EXTV_FLAG_CHROMAFILTER				0x80
#define CUI_EXTV_FLAG_DACMODERGB				0x100
#define CUI_EXTV_FLAG_DACMODEYC					0x200
#define CUI_EXTV_FLAG_DACMODECOMPOSITE			0x400
#define CUI_EXTV_FLAG_DACMODEHDTV				0x0800
#define CUI_EXTV_FLAG_DACMODEHDRGB				0x1000 
#define CUI_EXTV_FLAG_DACMODECOMPONENT			0x2000
#define CUI_EXTV_FLAG_AUTO_CONNECTOR_SELECTION	0x4000
#define CUI_EXTV_FLAG_LETTERBOX					0x8000
#define CUI_EXTV_FLAGS_TV_ASPECT_SCALING		0x10000 //support for TV Aspect Scaling RCR


typedef  struct { 
    CUIDriver_ERROR ErrorInfo; 
    DWORD           dwDevice;   //TV Display Device
    DWORD           dwFlags;    //Controlling features, OR of all supported features defined above

    CUI_EXTV_DATA   Sharpness; 
    CUI_EXTV_DATA   AdaptiveFlicker; 
    CUI_EXTV_DATA   TwoDFlicker; 
    CUI_EXTV_DATA   Saturation; 
    CUI_EXTV_DATA   Hue; 
    CUI_EXTV_DATA   DotCrawl; 
    CUI_EXTV_DATA   LumaFilter; 
    CUI_EXTV_DATA   ChromaFilter; 
    CUI_EXTV_DATA   DACModeRGB; 
    CUI_EXTV_DATA   DACModeYC; 
    CUI_EXTV_DATA   DACModeComposite; 
    CUI_EXTV_DATA   DACModeHDTV; 
    CUI_EXTV_DATA   DACModeHDRGB; 
    CUI_EXTV_DATA   DACModeComponent; 

} CUI_EXT_TV_CONTROL_DATA, *PCUI_EXT_TV_CONTROL_DATA, CUI_EXTTVCONTROL_DATA; 

// {A2781BE5-9231-4461-BBEC-097CA0C9E19C}
static const GUID VideoParameter = { 0xa2781be5, 0x9231, 0x4461, { 0xbb, 0xec, 0x9, 0x7c, 0xa0, 0xc9, 0xe1, 0x9c } };
// dwFlags
#define CUI_VP_FLAGS_TV_MODE        0x0001
#define CUI_VP_FLAGS_TV_STANDARD    0x0002
#define CUI_VP_FLAGS_FLICKER        0x0004
#define CUI_VP_FLAGS_OVERSCAN       0x0008
#define CUI_VP_FLAGS_MAX_UNSCALED   0x0010  // do not use on SET
#define CUI_VP_FLAGS_POSITION       0x0020
#define CUI_VP_FLAGS_BRIGHTNESS     0x0040
#define CUI_VP_FLAGS_CONTRAST       0x0080
#define CUI_VP_FLAGS_COPYPROTECT    0x0100
#define CUI_VP_FLAGS_OEM_CPPROTECT  0x0200

// dwMode
#define CUI_VP_MODE_WIN_GRAPHICS    0x0001  // the display is optimized for Windows
                                        // FlickerFilter on and OverScan off
#define CUI_VP_MODE_TV_PLAYBACK     0x0002  // optimize for TV video playback:
                                        // FlickerFilter off and OverScan on

// dwTVStandard
#define CUI_VP_TV_STANDARD_NTSC_M   0x0001  //        75 IRE Setup
#define CUI_VP_TV_STANDARD_NTSC_M_J 0x0002  // Japan,  0 IRE Setup
#define CUI_VP_TV_STANDARD_PAL_B    0x0004
#define CUI_VP_TV_STANDARD_PAL_D    0x0008
#define CUI_VP_TV_STANDARD_PAL_H    0x0010
#define CUI_VP_TV_STANDARD_PAL_I    0x0020
#define CUI_VP_TV_STANDARD_PAL_M    0x0040
#define CUI_VP_TV_STANDARD_PAL_N    0x0080
#define CUI_VP_TV_STANDARD_SECAM_B  0x0100  
#define CUI_VP_TV_STANDARD_SECAM_D  0x0200
#define CUI_VP_TV_STANDARD_SECAM_G  0x0400
#define CUI_VP_TV_STANDARD_SECAM_H  0x0800
#define CUI_VP_TV_STANDARD_SECAM_K  0x1000
#define CUI_VP_TV_STANDARD_SECAM_K1 0x2000
#define CUI_VP_TV_STANDARD_SECAM_L  0x4000
#define CUI_VP_TV_STANDARD_WIN_VGA  0x8000	// the display can do VGA graphics
#define CUI_VP_TV_STANDARD_NTSC_433 0x00010000
#define CUI_VP_TV_STANDARD_PAL_G    0x00020000
#define CUI_VP_TV_STANDARD_PAL_60   0x00040000
#define CUI_VP_TV_STANDARD_SECAM_L1 0x00080000
#define CUI_VP_TV_STANDARD_PAL_NC	0x00100000	// New Policy

// HDTV standard defination added using the unused upper 12 bits of dwTVStandard
#define CUI_VP_HDTV_SMPTE_170M_480i59   0x00100000
#define CUI_VP_HDTV_SMPTE_293M_480p60   0x00200000
#define CUI_VP_HDTV_SMPTE_293M_480p59   0x00400000
#define CUI_VP_HDTV_ITURBT601_576i50    0x00800000
#define CUI_VP_HDTV_ITURBT601_576p50    0x01000000
#define CUI_VP_HDTV_SMPTE_296M_720p50   0x02000000
#define CUI_VP_HDTV_SMPTE_296M_720p59   0x04000000
#define CUI_VP_HDTV_SMPTE_296M_720p60   0x08000000
#define CUI_VP_HDTV_SMPTE_274M_1080i50  0x10000000
#define CUI_VP_HDTV_SMPTE_274M_1080i59  0x20000000
#define CUI_VP_HDTV_SMPTE_274M_1080i60  0x40000000
#define CUI_VP_HDTV_SMPTE_274M_1080p60  0x80000000

// dwAvailableModes
#define CUI_VP_MODE_WIN_GRAPHICS    0x0001  // optimize for Windows display:
                                        // max FlickerFilter and OverScan off
#define CUI_VP_MODE_TV_PLAYBACK		0x0002  // optimize for TV video playback:
                                       // FlickerFilter off and OverScan on




#define CUI_CONNECTOR_TYPE_UNKNOWN              0xffffffff
#define CUI_CONNECTOR_TYPE_NONE                 0x00000000
#define CUI_CONNECTOR_TYPE_VGA                  0x00000001 //For CRT 
#define CUI_CONNECTOR_TYPE_LVDS                 0x00000002
#define CUI_CONNECTOR_TYPE_DVI                  0x00000004
#define CUI_CONNECTOR_TYPE_HDMI                 0x00000008
#define CUI_CONNECTOR_TYPE_SVIDEO               0x00000010
#define CUI_CONNECTOR_TYPE_COMPOSITE_VIDEO      0x00000020
#define CUI_CONNECTOR_TYPE_COMPONENT_VIDEO      0x00000040
#define CUI_CONNECTOR_TYPE_SECAM_VIDEO          0x00000080
#define CUI_CONNECTOR_TYPE_DISPLAY_PORT         0x00000100

//Content Protection structure
typedef struct { 
ULONG  dwCPType; 
ULONG  dwCPCommand; 
ULONG  dwCPStandard; 
ULONG  dwCPKey; 
ULONG  bCP_APSTriggerBits; 
UCHAR  bOEMCopyProtection[256]; 
}CUI_VIDEO_COPYPROTECT_DATA, *PCUI_VIDEO_COPYPROTECT_DATA;

// dwAvailableTVStandard
// see dwTVStandard
typedef struct { 
    CUIDriver_ERROR ErrorInfo; 
    DWORD           dwDevice;    //TV Display Device
    DWORD           dwFlags;    //Controlling features, OR of all supported features defined above
    
    DWORD           dwMode;
    DWORD           dwTVStandard;
    DWORD           dwAvailableModes;
    DWORD           dwAvailableTVStandard;
    DWORD           dwFlickerFilter;
    DWORD           dwOverScanX;
    DWORD           dwOverScanY;
    DWORD           dwMaxUnscaledX;
    DWORD           dwMaxUnscaledY;
    DWORD           dwPositionX;
    DWORD           dwPositionY;
    DWORD           dwBrightness;
    DWORD           dwContrast;
	CUI_VIDEO_COPYPROTECT_DATA structCopyProtect;
} CUI_VIDEO_PARAMETER_DATA, *PCUI_VIDEO_PARAMETER_DATA, CUI_VIDEOPARAMETER_DATA;

// {13E3288B-7E98-4380-8AAC-0D854DBB59DE}
static const GUID HDTVCaps ={ 0x13e3288b, 0x7e98, 0x4380, { 0x8a, 0xac, 0xd, 0x85, 0x4d, 0xbb, 0x59, 0xde } };
#define MAX_HDTV_MODES 100

typedef struct {

	IN SHORT			usXResolution;
	IN SHORT			usYResolution;
	IN SHORT			usColorBpp;
	IN SHORT			usReserved;
	OUT DWORD			ulSupportedStds; // Bit OR of all VP_HDTV_SMPTE Stds that support this X,Y
	OUT DWORD			ulPreferrredStd; // The VP_HDTV_SMPTE std for which this is the native resolution

} CUI_HDTV_MODE_INFO,  *PCUI_HDTV_MODE_INFO;

typedef struct {
	CUIDriver_ERROR     ErrorInfo;
	DWORD               dwDevice;	              //[IN]CUI Devices, Must be TV type
	DWORD		        dwNumOfModes;             //[IN] Number of modes inside ModeInfo[]
	CUI_HDTV_MODE_INFO 	ModeInfo[MAX_HDTV_MODES]; //Mode Table to get standard preference
} CUI_HDTV_CAPS, *PCUI_HDTV_CAPS;

/////////// INDRANIL DEFINES START /////////

//These three constants are specific values to the dwPersistOption.
#define CUI_HOTKEY_OPTIONS (1<<0) //For getting the Hotkey Persist options.

//
// this is now set up to id up to 4 of the same type of device on a pipe (may be overkill)
//
#define OUTPUT_UNKNOWN     (1<<31)

#define OUTPUT_CRT1        (1<<0)  //CRT 
#define OUTPUT_CRT2        (1<<1)
#define OUTPUT_CRT3        (1<<2)
#define OUTPUT_CRT4        (1<<3)

#define OUTPUT_TV1         (1<<4)   //TV
#define OUTPUT_TV2         (1<<5)
#define OUTPUT_TV3         (1<<6)
#define OUTPUT_TV4         (1<<7)

#define OUTPUT_DFP1        (1<<8)   //Extennal DFP 
#define OUTPUT_DFP2        (1<<9)
#define OUTPUT_DFP3        (1<<10)
#define OUTPUT_DFP4        (1<<11)

#define OUTPUT_LFP1        (1<<12)  //Internal LFP
#define OUTPUT_LFP2        (1<<13)
#define OUTPUT_LFP3        (1<<14)
#define OUTPUT_LFP4        (1<<15)

#define OUTPUT_NULL        (1<<16)     //XXX!!!: Not useful anymore...

//XXX: Those are PC13 backward compatible devices, should be deleted later...
#define OUTPUT_EXT_FP      OUTPUT_DFP
#define OUTPUT_ANALOG_TV   OUTPUT_TV1
#define OUTPUT_DIG_TV      OUTPUT_TV1  //XXX!!!: definitely have to change for PC14.

// Combos'
#define OUTPUT_CRT     (OUTPUT_CRT1|OUTPUT_CRT2 | OUTPUT_CRT3|OUTPUT_CRT4) 
#define OUTPUT_TV      (OUTPUT_TV1 | OUTPUT_TV2 | OUTPUT_TV3 | OUTPUT_TV4)
#define OUTPUT_DFP     (OUTPUT_DFP1 | OUTPUT_DFP2 | OUTPUT_DFP3 | OUTPUT_DFP4)
#define OUTPUT_LFP     (OUTPUT_LFP1|OUTPUT_LFP2 | OUTPUT_LFP3|OUTPUT_LFP4) 
#define ALL_DEVICES    (OUTPUT_CRT | OUTPUT_TV | OUTPUT_DFP | OUTPUT_LFP )
#define Null_Device    OUTPUT_NULL // determines last device reached

// DDC re-write start
// {AA8B8D96-2C90-4cac-8E5B-E17E1C078EBF}
static const GUID CombinedMode = 
{ 0xaa8b8d96, 0x2c90, 0x4cac, { 0x8e, 0x5b, 0xe1, 0x7e, 0x1c, 0x7, 0x8e, 0xbf } };

typedef struct _CUI_COMBINED_MODE_LIST
{
	CUIDriver_ERROR  ErrorInfo;
	/* IN */	 DWORD dwOpMode;
	/* IN */	 DWORD dwPrimaryDevice;
	/* IN */	 DWORD dwSecondaryDevice;
	/* OUT */	 DWORD dwNumPriModes;
	/* OUT */	 DWORD dwNumSecModes;
	/* OUT */	 CUIVIDEO_MODE  vmlModes[MAX_CUI_VIDEO_MODES];// Mode is just passed up as is
														// it's upto the user to convert it into strings or whatever
																// as required
}CUI_COMBINED_MODE_LIST, *PCUI_COMBINED_MODE_LIST;

// DDC rewrite end

// SDVO Firmware start

//SDVO encoder firmware interface definition

// {E67B70FC-504E-406b-9073-7617EF0D4D36}
static const GUID SDVOEncoder = { 0xe67b70fc, 0x504e, 0x406b, { 0x90, 0x73, 0x76, 0x17, 0xef, 0xd, 0x4d, 0x36 } };

// FLAGS	
#define ENCODER_FLAG_VENDOR_ID			0x0001
#define ENCODER_FLAG_DEVICE_ID			0x0002
#define ENCODER_FLAG_DEVICE_REV_ID		0x0004
#define ENCODER_FLAG_SDVO_VERSION_MINOR	0x0008
#define ENCODER_FLAG_SDVO_VERSION_MAJOR	0x0010
#define ENCODER_FLAG_FIRMWARE_REV		0x0020
#define ENCODER_FLAG_FIRMWARE_SIGNATURE	0x0040

// Structure to capture SDVO Firmware data...
typedef struct _CUI_SDVO_ENCODER_DATA {

	CUIDriver_ERROR  ErrorInfo;
	DWORD		dwFlags1;			// OR in each flag supported
	DWORD		dwVendorID1;
	DWORD		dwDeviceID1;
	DWORD		dwDeviceRevID1;
	DWORD		dwDeviceSDVOVersionMinor1;
	DWORD		dwDeviceSDVOVersionMajor1;
	DWORD		dwSDVOFirmwareRev1;
	unsigned __int64		dwSDVOFirmwareSignature1;
	DWORD		dwFlags2;			// OR in each flag supported
	DWORD		dwVendorID2;
	DWORD		dwDeviceID2;
	DWORD		dwDeviceRevID2;
	DWORD		dwDeviceSDVOVersionMinor2;
	DWORD		dwDeviceSDVOVersionMajor2;
	DWORD		dwSDVOFirmwareRev2;
	unsigned __int64		dwSDVOFirmwareSignature2;

}CUI_SDVO_ENCODER_DATA, *PCUI_SDVO_ENCODE_DATA;

// SDVO Firmware end

// TV Connector flags -- follow the def in itvout.h
#define TV_CONNECTED                        0x0001	// TV Attached to connector
#define TV_NOT_CONNECTED                    0x0002	// TV not attached to connector
#define TV_CONNECTION_STATUS_UNKNOWN        0x0003	// Error state
#define CURRENT_CONNECTOR_SELECTION         0x0004	// Cuurent Connector Selection


/************* PWM FREQUENCY CUI SDK RCR 942976 START *************/
// PWM Frequency. Should be same as pwrcons.h definitions
#define INVERTERI2C			0x01	// PWRCONS_INVERTER_I2C
#define INVERTER_PWM		0x02	// PWRCONS_INVERTER_PWM
#define INVERTER_UNKNOWN	0x04	// PWRCONS_INVERTER_UNKNOWN

// {B2F18520-3CD8-4d3e-8AC6-DED318050FE9}
static const GUID PWMFrequency = { 0xb2f18520, 0x3cd8, 0x4d3e, { 0x8a, 0xc6, 0xde, 0xd3, 0x18, 0x5, 0xf, 0xe9 } };

typedef struct _CUI_BACKLIGHT_PARAMS
{
	CUIDriver_ERROR	ErrorInfo;
	UINT	uiInverterType;
	ULONG	ulInverterFreq;
	ULONG   ulErrorTypes;
}CUI_BACKLIGHT_PARAMS, *PCUI_BACKLIGHT_PARAMS;

// Same as definitions in driver file pwrcons.h
#define CUI_PWRCONS_BACKLIGHT_PARAMS_SUCCESS                0x00000001
#define CUI_PWRCONS_BACKLIGHT_PARAMS_FAILURE                0x00000002
#define CUI_PWRCONS_BACKLIGHT_PARAMS_INVALID_INVERTER_TYPE  0x00000003
#define CUI_PWRCONS_BACKLIGHT_PARAMS_INVALID_FREQUENCY      0x00000004
/************* PWM FREQUENCY CUI SDK RCR 942976 END *************/


/******************* Vaildate-Advise interface Start *******************/
// {E0450AFC-0C0D-48c2-81DC-C16A5F4E125C}
static const GUID ValidateAdvise = { 0xe0450afc, 0xc0d, 0x48c2, { 0x81, 0xdc, 0xc1, 0x6a, 0x5f, 0x4e, 0x12, 0x5c } };

typedef struct _CUI_VALIDATE_ADVISE_CFG_MODE {
	CUIDriver_ERROR	ErrorInfo;
	bool bIsCfgOnly; // true = request is to Validate-Advise CFG only
	DWORD dwFlags; // From driver flag data
	CUI_SYSTEM_CONFIG in_stSystemCfg;
	CUI_SYSTEM_CONFIG out_stSystemCfg;
}CUI_VALIDATE_ADVISE_CFG_MODE, *PCUI_VALIDATE_ADVISE_CFG_MODE;

/*********** ERROR/STATUS FLAGS ***********/
// Error Codes. Should be same as in cuicom_esc.h
#define CUI_VALIDATE_OK							(1<<0)
#define CUI_VALIDATE_FAIL						(1<<1)
#define CUI_ADVISE_OK							(1<<2)
#define CUI_ADVISE_FAIL							(1<<3) 
#define CUI_NO_VALIDATION_HIDE_MODES_UNCHECKED	(1<<4)
#define CUI_FIRST_BOOT							(1<<5)

/******************* Vaildate-Advise interface END *******************/


typedef struct _CUI_CUSTOM_SCALING{
	DWORD	dwCustomActionMax;
	DWORD	dwCustomActionMin;
	DWORD	dwCustomActionCurrent;
	DWORD	dwCustomStep;
	DWORD	dwCustomDefault;
}CUI_CUSTOM_SCALING, *PCUI_CUSTOM_SCALING;


typedef struct _CUI_ASPECT_OPTIONS {
	CUIDriver_ERROR	ErrorInfo;
	DWORD	dwPrimaryDevice;
	DWORD	dwSecondaryDevice;
	DWORD	dwOperatingMode;
	BOOL	bIsSecondaryDevice;		//If secondary device information is required!
	DWORD	dwCurrentAspectOption;
	DWORD	dwSupportedAspectOption;
	DWORD	dwCurrentMediaCompensation; // PF2 - current settings
	DWORD	dwMediaCompensationCaps; // PF2 Capabilities
	CUI_CUSTOM_SCALING customScalingX;
	CUI_CUSTOM_SCALING customScalingY;


}CUI_ASPECT_OPTIONS, *PCUI_ASPECT_OPTIONS;

// SwitchToSPSD
// {CFD9169B-A99F-4e3c-B342-797671FE97A3}
static const GUID SwitchToSPSD = { 0xcfd9169b, 0xa99f, 0x4e3c, { 0xb3, 0x42, 0x79, 0x76, 0x71, 0xfe, 0x97, 0xa3 } };


// {0E3AAC90-5FD1-4dda-A218-4F32A35A7B5E}
static const GUID OverlayStatus = { 0xe3aac90, 0x5fd1, 0x4dda, { 0xa2, 0x18, 0x4f, 0x32, 0xa3, 0x5a, 0x7b, 0x5e } };

typedef struct _CUI_OVERLAY_STATUS
{
	CUIDriver_ERROR	ErrorInfo;
	BOOL bIsOverlayActive;

}CUI_OVERLAY_STATUS, *PCUI_OVERLAY_STATUS;

// Samsung DownScaler Start
// {74EB2103-161E-47a9-A7BD-CE53B9FD6F02}
static const GUID DownScale = { 0x74eb2103, 0x161e, 0x47a9, { 0xa7, 0xbd, 0xce, 0x53, 0xb9, 0xfd, 0x6f, 0x2 } };

#define DOWNSCALE_SUPPORTED	0x01	// To check if down scaler is supported or not
#define DOWNSCALE_ENABLED	0x02	// To check if down scaler is enabled or not
#define DOWNSCALE_ENABLE	0x03	// To Enable Down scale
#define DOWNSCALE_DISABLE	0x04	// To Disable Down scale

typedef struct _CUI_DOWNSCALE_PARAMS
{
	CUIDriver_ERROR	ErrorInfo;
	DWORD			dwFlags;
	BOOL			bIsSupported;
	BOOL			bIsEnabled;
	CUIVIDEO_MODE	MaxSupportedMode;	// Maximum mode that is supported
	CUIVIDEO_MODE	SourceMode;	// This is the mode that need to be set
	CUIVIDEO_MODE	LastMode;	// This is the mode set before
}CUI_DOWNSCALE_PARAMS, *PCUI_DOWNSCALE_PARAMS;
// Samsung DownScaler End
// {3542AE69-C6B5-4372-8DD6-A9565F1CEE62}
static const GUID DeviceInfo = { 0x3542ae69, 0xc6b5, 0x4372, { 0x8d, 0xd6, 0xa9, 0x56, 0x5f, 0x1c, 0xee, 0x62 } };

typedef struct _CUI_DEVICE_INFO
{
	CUIDriver_ERROR	ErrorInfo;
	DWORD dwDeviceID;
	BOOL bIsHDMIDevice;
	BOOL bIsCEDevice;
	CUIVIDEO_MODE   NativeMode; 

}CUI_DEVICE_INFO, *PCUI_DEVICE_INFO;

// {AF2221EF-90FA-4f98-A55B-9A744BD2B21D}
static const GUID ConnectorInfo = { 0xaf2221ef, 0x90fa, 0x4f98, { 0xa5, 0x5b, 0x9a, 0x74, 0x4b, 0xd2, 0xb2, 0x1d } };

typedef struct _CUI_CONNECTOR_INFO
{
	CUIDriver_ERROR	ErrorInfo;
	DWORD dwDeviceID;
	DWORD dwSupportedConnector;
	DWORD dwAttachedConnector;
	DWORD dwActiveConnector;
	DWORD dwDeviceInfo;
}CUI_CONNECTOR_INFO, *PCUI_CONNECTOR_INFO;


// MCCS structure

#define CUI_MAX_NUM_MCCS_PARAMS 0xFF	// same as MAX_NUM_MCCS_PARAMS Common.h
#define CUI_MAX_NUM_VALUES		0x0F	// same as MAX_NUM_VALUES Common.h

// This structure will be used both to get the list of supported controls
// as well as for non-continuous control code parameters.
typedef struct _CUI_MCCS_PARAMS
{
	CUIDriver_ERROR	ErrorInfo;
	UINT	uiControlCode; // Required for GetPossible functions
	UINT	uiNumValidParams;
	UINT	MCCS_Params[CUI_MAX_NUM_MCCS_PARAMS];
}CUI_MCCS_PARAMS, *PCUI_MCCS_PARAMS;


// {D498861B-BE6C-444f-95C7-2D8469CA55DF}
static const GUID DDCIndependentRotation = { 0xd498861b, 0xbe6c, 0x444f, { 0x95, 0xc7, 0x2d, 0x84, 0x69, 0xca, 0x55, 0xdf } };

typedef struct _CUI_DDCROTATION_OPTIONS {
	CUIDriver_ERROR	ErrorInfo;
	DWORD	dwIsDDCRotationSupported;		// 1 if Independent rotation is supported by the driver.
	DWORD	dwIs90270RotationSupported ;   //1 if 90 / 270 independent rotation supported by driver
	DWORD	dwIsFeatureEnable;			//1, if the feature to apply is being done using CUI
	DWORD	dwPrimaryDevice;		
	DWORD	dwSecondaryDevice;
	DWORD	dwPrimaryRotationAngle;
	DWORD	dwSecondaryRotationAngle;

	DWORD	dwPrimaryRotationCaps;
	DWORD	dwSecondaryRotationCaps;


}CUI_DDCROTATION_OPTIONS, *PCUI_DDCROTATION_OPTIONS;

// {9E47675F-7493-4636-9308-22B02738DA0B}
static const GUID ColorValues = 
{ 0x9e47675f, 0x7493, 0x4636, { 0x93, 0x8, 0x22, 0xb0, 0x27, 0x38, 0xda, 0xb } };

//Color Buffer size is 36 bytes ie 4 bytes for 3 colors(Red,Green,Blue) for each of Gamma,Brightness,Contrast(ie 9 * 4bytes = 36 bytes)
#define COLOR_BUFFER_SIZE 36
typedef struct _CUI_COLOR_VALUES
{
	CUIDriver_ERROR	ErrorInfo;
	DWORD dwDeviceID;
	DWORD dwColorIndex;
	BYTE  colorBuffer[COLOR_BUFFER_SIZE];

}CUI_COLOR_VALUES, *PCUI_COLOR_VALUES;
// For TV format New Policy -- PAL_Nc support Same as CommonUtils.h
#define TV_FORMAT_NEW_POLICY	0xF9


static const GUID UserName = { 0x5a2eb609, 0xc1cf, 0x4039, { 0xad, 0xd7, 0x1d, 0xaa, 0x94, 0xc1, 0x53, 0xe2 } };

typedef struct _CUI_USER_DATA {
	CUIDriver_ERROR ErrorInfo;
	TCHAR UserName[256];
	BOOL bIsLogOff; /// TRUE when system is log off
					
}CUI_USER_DATA, *PCUI_USER_DATA;


static const GUID CUIPersistConfig  = { 0x96f2cf65, 0xf35d, 0x460c, { 0xab, 0x1c, 0x11, 0xab, 0xf9, 0x3a, 0x8c, 0x1c } };

static const GUID CUINextConfig = { 0x5d176783, 0xcaff, 0x4881, { 0x8a, 0xde, 0x93, 0x2f, 0xbc, 0xa7, 0x3f, 0x78 } };

static const GUID TMMModifyConfigData = { 0xa18a1bfd, 0xfc51, 0x4ad0, { 0x84, 0x7d, 0xdd, 0xa7, 0x65, 0x1, 0x3a, 0xd2 } };

typedef struct _CUI_NEXTCONFIG_INFO {

	CUIDriver_ERROR ErrorInfo;
	BOOL bIsConfigRequiredFromCUI;
	CUI_SYSTEM_CONFIG	SystemConfig;
	DWORD	dwPrimaryOrientation;
	DWORD	dwSecondaryOrientation;
	DWORD	dwFlags;

}CUI_NEXTCONFIG_INFO, *PCUI_NEXTCONFIG_INFO;

//For TMM to expose Xlate functions
// {7627DB20-52D8-421f-A968-2153997D3B80}
static const GUID XTranslate = 
{ 0x7627db20, 0x52d8, 0x421f, { 0xa9, 0x68, 0x21, 0x53, 0x99, 0x7d, 0x3b, 0x80 } };

typedef struct _CUI_XLATE_FUNC
{
	CUIDriver_ERROR	ErrorInfo;
	DWORD dwCUIdeviceID;
	ULONG ulUID;
}CUI_XLATE_FUNC, *PCUI_XLATE_FUNC;

//For First Boot after Facoty Install
// {B657AAF8-E929-4314-97E9-A6AF42788D7D}
static const GUID FirstBootInfo = 
{ 0xb657aaf8, 0xe929, 0x4314, { 0x97, 0xe9, 0xa6, 0xaf, 0x42, 0x78, 0x8d, 0x7d } };

#define FIRSTBOOTFACTORYINSTALL	0x8086
#define FIRSTBOOTSYSTEM			0x02
#define FRESHINSTALL			0x04

typedef struct _CUI_FIRSTBOOT_INFO
{
	CUIDriver_ERROR	ErrorInfo;
	BOOL bFirstBootFactoryInstall;	// TRUE means it is first boot after factory install.
	BOOL bFirstBootSystem;			// TRUE means this is the first boot of the system after OS and driver install 
	BOOL bFreshInstall;				// TRUE means it is fresh install of driver or driver upgrade
	DWORD dwOEMHRes;				//OEM specified X value
	DWORD dwOEMVRes;				//OEM specified Y value
	DWORD dwOEMBpp;					//OEM specified bpp value
	DWORD dwOEMRate;				//OEM specified refresh rate value

}CUI_FIRSTBOOT_INFO, *PCUI_FIRSTBOOT_INFO;

// For Persistence Disable through CUI SDK
// {6B0388BF-F891-4967-91EE-7452B7EACAC6}
static const GUID DrvPrstDisable =
{ 0x6b0388bf, 0xf891, 0x4967, { 0x91, 0xee, 0x74, 0x52, 0xb7, 0xea, 0xca, 0xc6 } };

typedef struct _CUI_DRVPRSTDSBL_INFO
{
	CUIDriver_ERROR	ErrorInfo;
	DWORD	dwStatus;
}CUI_DRVPRSTDSBL_INFO, *PCUI_DRVPRSTDSBL_INFO;
//587751f2-abcb-4665-b6cf-6f502c7638e0
static const GUID TMMActiveStatus =
{ 0x587751f2, 0xabcb, 0x4665, { 0xb6, 0xcf, 0x6f, 0x50, 0x2c, 0x76, 0x38, 0xe0 } };
typedef struct _CUI_TMM_ACTIVE
{
    CUIDriver_ERROR	ErrorInfo;
	BOOL	bActive;
}CUI_TMM_ACTIVE, *PCUI_TMM_ACTIVE;

// made these entries same as in igfxext\Common.h entries
#define CUI_DATA_NOT_AVAILABLE			0x00000000
#define CUI_DISABLE_DRIVER_PERSISTENCE	0x00000001
#define CUI_ENABLE_DRIVER_PERSISTENCE	0x00000002

/**
	HDMI INFO FRAME STRUCTURES
**/
// {CAAE1971-D88C-4dca-BFFF-D306BC274D33}
static const GUID HDMIInfoFrame = 
{ 0xcaae1971, 0xd88c, 0x4dca, { 0xbf, 0xff, 0xd3, 0x6, 0xbc, 0x27, 0x4d, 0x33 } };

typedef enum
{
    CUI_HDMI_COMMAND_GET,
    CUI_HDMI_COMMAND_SET
} CUI_HDMI_COMMAND;

typedef struct _CUI_IF_HEADER
{
    UCHAR ucType;       // InfoFrame Type
    UCHAR ucVersion;    // InfoFrame Version
    UCHAR ucLength;     // InfoFrame Length
    UCHAR ucChksum;     // Checksum of the InfoFrame
}CUI_IF_HEADER, *PCUI_IF_HEADER;

typedef struct _CUI_VS_IF
{
    CUI_IF_HEADER IfHeader; // VS header data
    UCHAR ucIEEERegID[3];   // 3-byte IEEE registration ID
    UCHAR ucPayload[24];        // Payload bytes
 
}CUI_VS_IF, *PCUI_VS_IF;

typedef struct _CUI_HDMI_INFOFRAME
{
	CUIDriver_ERROR ErrorInfo;
	DWORD	dwDeviceID;
    GUID            Guid;
    CUI_HDMI_COMMAND    dwCommand;
    UCHAR           ucType;
    UCHAR           ucSize;
    CUI_VS_IF	VS_INFOFRAME;
    
}CUI_HDMI_INFOFRAME, *PCUI_HDMI_INFOFRAME;
/**
	HDMI INFO FRAME STRUCTURES END
**/
/* SDVO Vendor Opcode START */

// {203792E4-1CA9-4001-BA8A-22FFAB5858F9}
static const GUID SDVOVendorOpcode = 
{ 0x203792e4, 0x1ca9, 0x4001, { 0xba, 0x8a, 0x22, 0xff, 0xab, 0x58, 0x58, 0xf9 } };

// This enum should be same as of SDVO_CMD_STATUS in AIM
// and IGFX_SDVO_CMD_STATUS as in igfxext\Common.h
typedef enum _CUI_SDVO_CMD_STATUS 
{
	CUI_SDVO_POWER_ON_STATE	        		= 0,
	CUI_SDVO_SUCCESS               			= 1,
	CUI_SDVO_COMMAND_NOT_SUPPORTED         	= 2,
	CUI_SDVO_INVALID_ARGUEMENT         		= 3,
	CUI_SDVO_PENDING               			= 4,
	CUI_SDVO_TARGET_NOT_SPECIFIED      		= 5,
	CUI_SDVO_DEVICE_SCALING_NOT_SUPPORTED	= 6
}CUI_SDVO_CMD_STATUS;

typedef struct _CUI_VENDOR_OPCODE_ARGS
{
			CUIDriver_ERROR		ErrorInfo;
	/*IN*/	GUID				guid;
	/*IN*/	DWORD 				dwDeviceAddress;
	/*IN*/	DWORD 				dwOpcode;
	/*IN*/	BYTE   				ParamIn[8];
	/*IN*/	DWORD 				dwParamInCount;
	/*OUT*/ BYTE   				Return[8];
	/*OUT*/ DWORD	 			dwReturnCount;
	/*OUT*/ CUI_SDVO_CMD_STATUS CmdStatus;
			DWORD 				Reserved1;
			DWORD 				Reserved2;
}CUI_VENDOR_OPCODE_ARGS, *PCUI_VENDOR_OPCODE_ARGS;

/* SDVO Vendor Opcode END */

/* Feature Support Begin */

// {FE11FB99-C6B5-45bd-A625-ACE4A3BD808B}
static const GUID FeatureSupport = 
{ 0xfe11fb99, 0xc6b5, 0x45bd, { 0xa6, 0x25, 0xac, 0xe4, 0xa3, 0xbd, 0x80, 0x8b } };

typedef struct _CUI_FEATURE_SUPPORT_ARGS
{
			CUIDriver_ERROR	ErrorInfo;
	/*OUT*/ DWORD			dwFeatureSupport;
			DWORD			Reserved1;
}CUI_FEATURE_SUPPORT_ARGS, *PCUI_FEATURE_SUPPORT_ARGS;

/* Feature Support End */

/* Feature Test Control Start */
// For enable/disable power conservation features through registry
// {8A7A4D55-0602-4a4f-B6B2-5381811995DF}
static const GUID FeatureControl = 
{ 0x8a7a4d55, 0x602, 0x4a4f, { 0xb6, 0xb2, 0x53, 0x81, 0x81, 0x19, 0x95, 0xdf } };

/* Feature Test Control End */


// {D9D3D3D8-1F85-43f2-B961-2DFAB0C03226}
static const GUID DriverRegDWORD = 
{ 0xd9d3d3d8, 0x1f85, 0x43f2, { 0xb9, 0x61, 0x2d, 0xfa, 0xb0, 0xc0, 0x32, 0x26 } };

typedef struct _CUI_DRIVER_REG_DWORD
{
	CUIDriver_ERROR	ErrorInfo;
	unsigned int uiDisplayNumber;
	WCHAR szEntry[MAX_PATH];
	DWORD dwValue;
}CUI_DRIVER_REG_DWORD, *PCUI_DRIVER_REG_DWORD;
// Static Display Device
// {6349DDB3-D436-411d-AE23-1C7E5306B09B}
static const GUID StaticDisplayDevice = 
{ 0x6349ddb3, 0xd436, 0x411d, { 0xae, 0x23, 0x1c, 0x7e, 0x53, 0x6, 0xb0, 0x9b } };


/************PanelFitting********************/
//For PanelFitting
// {77B3A0CE-EF6A-4000-9275-4B702DBEED23}
static const GUID PanelFitInfo = 
{ 0x77b3a0ce, 0xef6a, 0x4000, { 0x92, 0x75, 0x4b, 0x70, 0x2d, 0xbe, 0xed, 0x23 } };


typedef struct _CUI_PANELFIT_INFO
{
	CUIDriver_ERROR	ErrorInfo;
	BOOL bIsPanelFitRequested;	// TRUE means Requested for panel fit
	ULONG ulPanelFitType;			// type of the panel fit
}CUI_PANELFIT_INFO, *PCUI_PANELFIT_INFO;

//for pnp notifications
// {3056265E-137F-4a86-B80D-301978A68411}
static const GUID PnpEventInfo = 
{ 0x3056265e, 0x137f, 0x4a86, { 0xb8, 0xd, 0x30, 0x19, 0x78, 0xa6, 0x84, 0x11 } };
static const GUID CUI_DisplayInterface = 
{ 0xe6dfdc31, 0x31d0, 0x46ac, { 0x86, 0xaf, 0xda, 0x1e, 0xb0, 0x5f, 0xc5, 0x99 } };
enum CUI_EVENTS
{
	CUI_EVENT_INVALID=0,
	CUI_EVENT_HOTKEY=1,
	CUI_EVENT_LIDSWITCH=2,
	CUI_EVENT_HOTPLUG=4,
	CUI_EVENT_POWER=8,
	CUI_EVENT_DOCK=16,
	CUI_EVENT_LOCK=32,
	CUI_EVENT_IGPUACTIVE = 64,
    CUI_EVENT_DGPUACTIVE = 128,
	CUI_EVENT_PIPE_PLANE_OPTIMIZATION=256
};
typedef struct _CUI_PNPEVENT_INFO
{
	CUIDriver_ERROR	ErrorInfo;
	CUI_EVENTS eEvents;
}CUI_PNPEVENT_INFO,*PCUI_PNPEVENT_INFO;

/*****************CRT/TV Static Detection************/
//For CRT/TV Static Detection
// {D5F9CBB2-EB88-444a-96D5-8013DB8918A2}
static const GUID StaticDetection = 
{ 0xd5f9cbb2, 0xeb88, 0x444a, { 0x96, 0xd5, 0x80, 0x13, 0xdb, 0x89, 0x18, 0xa2 } };

typedef struct _CUI_STATIC_INFO
{
	CUIDriver_ERROR	ErrorInfo;
	BOOL bIsStaticDetectionSupported;
}CUI_STATIC_INFO,*PCUI_STATIC_INFO;

/************CustomModeInfo********************/
//For CustomModeAddition
// {20F24146-2C80-4904-824D-05DFD5D85BF0}
#define MIN_RR				50
#define MAX_RR				120
#define MIN_XRES			320
#define MIN_YRES			200
static const GUID AddCustomModes = 
{ 0x20f24146, 0x2c80, 0x4904, { 0x82, 0x4d, 0x5, 0xdf, 0xd5, 0xd8, 0x5b, 0xf0 } };

//Flags
#define CUI_FLAG_BASIC_MODE		1
#define CUI_FLAG_ADV_MODE		2
#define CUI_FLAG_ALL_MODE		(CUI_FLAG_BASIC_MODE | CUI_FLAG_ADV_MODE)
#define CUI_FLAG_REMOVE_MODE	4
typedef enum _CUI_CUSTOM_MODE_TIMING_STD
{
	CUI_GTF_STD = 0,
	CUI_CVT_STD,
	CUI_CVT_RB_STD,
	CUI_CE_861_B
}CUI_CUSTOM_MODE_TIMING_STD;
//Struct for the Basic Mode info
typedef struct _CUI_BASIC_MODE
{
	DWORD dwColor;
	BOOL  bScanType;
	DWORD dwRR;
	DWORD dwHActive;
	DWORD dwVActive;
	DWORD dwTimingAlgo;
	DWORD dwUnderscan;
}CUI_BASIC_MODE, *PCUI_BASIC_MODE;
//Struct for the Advanced Mode info
typedef struct _CUI_ADV_MODE
{
	DWORD dwColor;
	BOOL  bScanType;
	DWORD dwHActive;
	DWORD dwHFrontPorch;
	DWORD dwHBackPorch;
	DWORD dwHSyncWidth;
	BOOL  bHSyncPolarity;
	DWORD dwHScanRate;
	DWORD dwVActive;
	DWORD dwVFrontPorch;
	DWORD dwVBackPorch;
	DWORD dwVSyncWidth;
	BOOL  bVSyncPolarity;
	DWORD dwVScanRate;
}CUI_ADV_MODE, *PCUI_ADV_MODE;
typedef struct _CUI_ADD_CUSTOM_MODE
{
	CUIDriver_ERROR	ErrorInfo;
	DWORD dwDeviceID;
	DWORD dwFlag;  
	BOOL bForceModeAddition;
    CUI_BASIC_MODE 	BasicMode;
    CUI_ADV_MODE 	AdvMode;
}CUI_ADD_CUSTOM_MODE, *PCUI_ADD_CUSTOM_MODE;

// {DF95D261-87D0-425e-B7EC-D68F0D4759A5}
static const GUID CustomModeList = 
{ 0xdf95d261, 0x87d0, 0x425e, { 0xb7, 0xec, 0xd6, 0x8f, 0xd, 0x47, 0x59, 0xa5 } };

//Structure to get all the added modes
typedef struct _CUI_CUSTOM_MODE_LIST
{
	CUIDriver_ERROR	ErrorInfo;
	DWORD dwDeviceID;
	DWORD dwFlag;
	DWORD dwTotalModes;
	CUI_BASIC_MODE Modelist[MAX_CUI_VIDEO_MODES];
}CUI_CUSTOM_MODE_LIST, *PCUI_CUSTOM_MODE_LIST;

// {6353717F-683D-4d35-A6FF-B576E63ECEDC}
static const GUID CustomModeTiming = 
{ 0x6353717f, 0x683d, 0x4d35, { 0xa6, 0xff, 0xb5, 0x76, 0xe6, 0x3e, 0xce, 0xdc } };

//Structure to get all the added modes
typedef struct _CUI_CUSTOM_MODE_TIMING
{
	CUIDriver_ERROR	ErrorInfo;
	DWORD dwDeviceID;
	DWORD dwFlag;
	CUI_BASIC_MODE 	BasicMode;
    CUI_ADV_MODE 	AdvMode;	
}CUI_CUSTOM_MODE_TIMING, *PCUI_CUSTOM_MODE_TIMING;

//Media settings changes
#define szMediaValues    "Software\\Intel\\Display\\igfxcui\\Media"		//localization OK
#define szEnableFMD				_T("EnableFMD")
#define szEnableNoiseReduction	_T("NoiseReductionEnabledAlways")
#define szSharpnessFactor		_T("SharpnessFactor")
#define szEnableSharpness		_T("SharpnessEnabledAlways")
#define szProcAmpApplyAlways	_T("ProcAmpApplyAlways")
#define szProcAmpHue			_T("ProcAmpHue")
#define szProcAmpSaturation		_T("ProcAmpSaturation")
#define szProcAmpContrast		_T("ProcAmpContrast")
#define szProcAmpBrightness		_T("ProcAmpBrightness")
#define szEnableNLAS			_T("EnableNLAS")
#define szNLASVerticalCrop		_T("NLASVerticalCrop")
#define szNLASHLinearRegion		_T("NLASHLinearRegion")
#define szNLASNonLinearCrop		_T("NLASNonLinearCrop")

//Bug fix for VideoSetting Slider issue 106759
//the values stored under these keys will be used to show
//up the correct values on slider control
#define szUINLASHLinearRegion	_T("UINLASHLinearRegion")
#define szUINLASNonLinearCrop	_T("UINLASNonLinearCrop")

#define CUI_VIDEO_FMD			   0x0004	// Media Settings, to indicate if Film Mode detection is supported/not
#define CUI_VIDEO_NOISE			   0x0008	// Media Settings, to indicate if DENOISE is supported/not
#define CUI_VIDEO_PROCAMP		   0x0010   // Media Settings, to indicate if ProcAmp is supported/not
#define CUI_VIDEO_NLAS			   0x0020	// Media Settings, to indicate if NLAS is supported/not
#define CUI_VIDEO_SHARPNESS		   0x0040	// Media Settings, to indicate if Sharpness is supported/not

//Video cleanup
#define CLEANUP_DEF_FMD			1
#define CLEANUP_DEF_NOISE		1
#define CLEANUP_DEF_SHARP		0
#define CLEANUP_MIN_SHARPNESS	0.0
#define CLEANUP_DEF_SHARPNESS	0.0
#define CLEANUP_MAX_SHARPNESS	512.0

//Proc Amp Default values
#define PROCAMP_DEF_APPLYALWAYS		0
#define PROCAMP_MIN_HUE				-180.0
#define PROCAMP_DEF_HUE				0.0
#define	PROCAMP_MAX_HUE				180.0
#define PROCAMP_MIN_SAT				0.0
#define PROCAMP_DEF_SAT				1.0
#define PROCAMP_MAX_SAT				10.0
#define PROCAMP_MIN_BRIGHT			-100.0
#define PROCAMP_DEF_BRIGHT			0.0
#define PROCAMP_MAX_BRIGHT			100.0
#define PROCAMP_MIN_CONTRAST		0.0
#define PROCAMP_DEF_CONTRAST		1.0
#define PROCAMP_MAX_CONTRAST		10.0

//Video Scaling
#define SCALING_DEF_NLAS			0
#define SCALING_MIN_VCROP			0.0
#define SCALING_DEF_VCROP			0.0
#define SCALING_MAX_VCROP			1.0

#define SCALING_MIN_HLIN_REG		0.11
#define SCALING_DEF_HLIN_REG		0.11
#define SCALING_MAX_HLIN_REG		0.75

#define SCALING_MIN_NLIN_CROP		0.0
#define SCALING_DEF_NLIN_CROP		0.0
#define SCALING_MAX_NLIN_CROP		0.4

// {84FA8F92-FB77-4d1f-B35C-238906F28095}
static const GUID MediaInfo = 
{ 0x84fa8f92, 0xfb77, 0x4d1f, { 0xb3, 0x5c, 0x23, 0x89, 0x6, 0xf2, 0x80, 0x95 } };
typedef struct
{
    float           fValue;    //Current Value
    float           fDefault;  //Default Value 
    float           fMin;      //Minimium Value 
    float           fMax;      //Maximium Value 
    float           fStep;     //Adjustment value for each step
}CUI_MEDIA_DATA, *PCUI_MEDIA_DATA;
/**************** Video Settings structure ******************************/
//Video Quality page
typedef struct _videoQuality{
	
	BOOL bProcess;
	
	DWORD dwSupported; //0x00 - No Support, 0x02 - FMD,0x04 - Sharpness Enhacement etc
	BOOL bFilmModeDetection; //enable - 1, disable - 0
	BOOL bEnableFMDDef;

	BOOL bEnableNoiseReduction; 
	BOOL bEnableNoiseReductionDef;

	BOOL bEnableSharpness; 
	BOOL bEnableSharpnessDef;
	
	CUI_MEDIA_DATA Sharpness;
}videoQuality;

//Proc Amp page (Color Control)
typedef struct _videoColor{
	
	BOOL bProcess;
	
	DWORD dwSupported;
	BOOL bEnableAlways;
	BOOL bEnableAlwaysDef;

	CUI_MEDIA_DATA Hue;
	CUI_MEDIA_DATA Saturation;
	CUI_MEDIA_DATA Contrast;
	CUI_MEDIA_DATA Brightness;
}videoColor;

//Video Scaling
typedef struct _videoScaling{

	BOOL bProcess;
	
	DWORD dwSupported;
	BOOL bEnableNLAS;
	BOOL bEnableNLASDef;

	CUI_MEDIA_DATA VerticalCrop;
	CUI_MEDIA_DATA HLinearRegion;
	CUI_MEDIA_DATA NonLinearCrop;	
}videoScaling;
//Main Video structure
typedef struct _CUI_MEDIA_INFO{
	CUIDriver_ERROR	ErrorInfo;
	videoQuality Quality;
	videoColor	Color;
	videoScaling	Scaling;
}CUI_MEDIA_INFO,*PCUI_MEDIA_INFO;

//For querying driver on Gamma Support
// {AD0C9261-651D-42fd-80E3-24A658427B7D}
static const GUID  GammaSupport = 
{ 0xad0c9261, 0x651d, 0x42fd, { 0x80, 0xe3, 0x24, 0xa6, 0x58, 0x42, 0x7b, 0x7d } };

//use the existing structure to ask driver if Gamma is supported on a device/not
typedef CUIBOOLEAN CUI_GAMMA_SUPPORT_INFO;


//For passing Display link capability(version,display type,no of displays) down to driver
// {545CDA10-51AB-47b7-A4D4-68AF766E70E4}
static const GUID DLCapability = 
{ 0x545cda10, 0x51ab, 0x47b7, { 0xa4, 0xd4, 0x68, 0xaf, 0x76, 0x6e, 0x70, 0xe4 } };

#define CUI_NIVO_DVI 	1  // Specifies that the device type is DVI

typedef struct _CUI_DLCAPS
{
	CUIDriver_ERROR ErrorInfo;

	DWORD dwFlags; //refers to the type of NIVO device 

	DWORD dwDLVersion; //(LOWORD  Minor version, HIWORD  Major version)

	DWORD dwNumDevices;//refers to the maximum possible NIVO devices of a particular type (as specified in dwFlags) on the system

	DWORD dwReserved1;//Reserved, can be used for future purpose
	
	DWORD dwReserved2;//Reserved, can be used for future purpose
}CUI_DLCAPS, *PCUI_DLCAPS;

//HG Nvidia-ACPI device ID structure declaration 

static const GUID HGNvidiaData = 
{ 0x5bbbf454, 0x1fa7, 0x45ac, { 0x83, 0xb5, 0x2a, 0xc2, 0xaa, 0x7e, 0xeb, 0x29 } };

typedef struct _CUI_HGNvidia_Device_Status
{    	 
	ULONG       bNvConnected :1 ; // True When Display is attached
	ULONG       bNvActive    :1 ; // True when this display is active
	ULONG       bNvSupported :1 ; // True if the Display is supported
	ULONG       bNvHasEdid   :1 ; // EDID data is included
	ULONG       Reserved     :28 ;	 
}CUI_HGNvidia_Device_Status;


typedef struct _CUI_HGNvidia_Data
{	
	CUIDriver_ERROR	ErrorInfo;
	CUI_HGNvidia_Device_Status devStatus;
	DWORD              dwDisplayUID;// Display Device UID
    DWORD              dwACPIID;  //ACPI 3.0 ID of display device
    BYTE               ucEDID[256]; // First 256-Bytes of Display EDID		

}CUI_HGNvidia_Data,*PCUI_HGNvidia_Data;

//Scaling structure
// {698D5CF0-8307-4ed3-BC43-03631AD62C40}
static const GUID HGScalingData = 
{ 0x698d5cf0, 0x8307, 0x4ed3, { 0xbc, 0x43, 0x3, 0x63, 0x1a, 0xd6, 0x2c, 0x40 } };

typedef struct _CUI_HG_Display_Sclaing { // all are unrotated dimensions
	CUIDriver_ERROR	ErrorInfo;
    struct {
        DWORD dwSourceWidth;
        DWORD dwSourceHeight;
    } SourceRes; // dimensions of the source bitmap
    struct {
        DWORD dwScaledWidth;
        DWORD dwScaledHeight;
    } ScaledRes; // dimensions of the image after adapter scaling
    struct {
        DWORD dwDisplayWidth;
        DWORD dwDisplayHeight;
    } DisplayRes; // dimensions of the screen
	DWORD dwDisplayUID;//Display UID  
}CUI_HG_Display_Sclaing, *PCUI_HG_Display_Sclaing;

// {19E75859-C7BB-4c13-85C1-33D041C04157}
static const GUID DriverRegBINARY = 
{ 0x19e75859, 0xc7bb, 0x4c13, { 0x85, 0xc1, 0x33, 0xd0, 0x41, 0xc0, 0x41, 0x57 } };
typedef struct _CUI_DRIVER_REG_BINARY
{
	/*OUT*/CUIDriver_ERROR	ErrorInfo;
	/*IN*/unsigned int uiDisplayNumber;
	/*IN*/WCHAR szEntry[MAX_PATH];
	/*IN*/ /*OUT*/ BYTE        buffer[MAX_BUFFER_SIZE];
}CUI_DRIVER_REG_BINARY, *PCUI_DRIVER_REG_BINARY;
//HG-Nvidia-end

//Default values for color
// {77F33EA5-84BD-47d9-AF47-7BE4A560D513}
static const GUID DefaultColorValues = 
{ 0x77f33ea5, 0x84bd, 0x47d9, { 0xaf, 0x47, 0x7b, 0xe4, 0xa5, 0x60, 0xd5, 0x13 } };
typedef struct _CUI_COLOR_DEFAULT
{
	/*OUT*/CUIDriver_ERROR	ErrorInfo;
	/*OUT*/ int iBrightnessDefault;
	/*OUT*/ int iContrastDefault;
	/*OUT*/ int iGammaDefault;
}CUI_COLOR_DEFAULT, *PCUI_COLOR_DEFAULT;
#endif            // __CUI_USERSTRUCTURES_H_   (End of File)
